// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"fmt"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

{{.HelperImport}}
{{.CommonImport}}
baseClientset {{.BaseClientsetImport}}
fakeBaseClienset {{.FakeBaseCliensetImport}}

{{.BaseImports}}
)
type Clientset struct {
	baseClient baseClientset.Interface
	{{ range $key, $group := .ApiGroups }}{{$group.ClientsetApiGroups}}{{ end }}
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	{{ range $key, $group := .ApiGroups }}{{$group.InitApiGroups}}{{ end }}

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	{{ range $key, $group := .ApiGroups }}{{$group.InitApiGroups}}{{ end }}
	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

{{ range $key, $group := .ApiGroups }}{{$group.ClientsetsApiGroupMethods}}{{ end }}

{{ range $key, $group := .ApiGroups }}
type
{{$group.GroupTypeName}} struct {
client *Clientset
}

func new{{$group.GroupTypeName}}(client *Clientset) *{{$group.GroupTypeName}} {
	return &{{$group.GroupTypeName}}{
		client: client,
	}
}
{{end}}


{{ range $key, $node := .Nodes }}
// Get{{$node.BaseNodeName}}ByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) Get{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

// Delete{{$node.BaseNodeName}}ByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) Delete{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (err error) {
	{{if or .HasChildren .Parent.HasParent }}
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}
	{{ end }}

	{{ range $key, $link := .Children }}
	{{ if $link.IsNamed }}
	for _, v := range result.Spec.{{$link.FieldName}}Gvk {
		err := group.client.
		{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}
	{{ else }}
	if result.Spec.{{$link.FieldName}}Gvk != nil {
		err := group.client.
		{{$link.SimpleGroupTypeName}}().
		Delete{{$link.BaseNodeName}}ByName(ctx, result.Spec.{{$link.FieldName}}Gvk.Name)
		if err != nil {
			return err
		}
	}
	{{ end }}
	{{ end }}

	err = group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	{{if .Parent.HasParent}}
	var patch Patch
	{{if .Parent.IsNamed}}
	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/{{$node.Parent.GvkFieldName}}/" + result.DisplayName(),
	}
	{{ else }}
	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/{{$node.Parent.GvkFieldName}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", parents, parentName)
	}
	_, err = group.client.baseClient.
	{{$node.Parent.GroupTypeName}}().
	{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	{{ end }}

	return
}

// Create{{$node.BaseNodeName}}ByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *{{$node.GroupTypeName}}) Create{{$node.BaseNodeName}}ByName(ctx context.Context,
	objToCreate *{{$node.GroupBaseImport}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	{{ range $key, $link := .LinksAndChildren }}objToCreate.Spec.{{$link.FieldName}}Gvk = nil
	{{ end }}
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	{{if .Parent.HasParent}}
	parentName, ok := objToCreate.GetLabels()["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", objToCreate.GetLabels(), parentName)
	}
	{{if .Parent.IsNamed}}
	payload := "{\"spec\": {\"{{$node.Parent.GvkFieldName}}\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"{{$node.Kind}}\", \"group\": \"{{$node.Group}}\"}}}}"
	_, err = group.client.baseClient.
	{{$node.Parent.GroupTypeName}}().
	{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/{{$node.Parent.GvkFieldName}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$node.Group}}",
		Kind:  "{{$node.Kind}}",
		Name:  objToCreate.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
	{{$node.Parent.GroupTypeName}}().
	{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ end }}
	{{ end }}

	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

// Update{{$node.BaseNodeName}}ByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *{{$node.GroupTypeName}}) Update{{$node.BaseNodeName}}ByName(ctx context.Context,
	objToUpdate *{{$node.GroupBaseImport}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	}
	patch = append(patch, patchOpMeta)
	{{ range $key, $field := .Fields }}
	patchValue{{$field.FieldName}} :=
	objToUpdate.Spec.{{$field.FieldName}}
		patchOp{{$field.FieldName}} := PatchOp{
		Op:    "replace",
		Path:  "/spec/{{$field.FieldNameTag}}",
		Value: patchValue{{$field.FieldName}},
	}
	patch = append(patch, patchOp{{$field.FieldName}})
	{{ end }}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
	client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

// List{{$node.GroupResourceNameTitle}} returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *{{$node.GroupTypeName}}) List{{$node.GroupResourceNameTitle}}(ctx context.Context,
	opts metav1.ListOptions) (result []*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	list, err := group.client.baseClient.{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, len(list.Items))
	for k, v := range list.Items {
		result[k] = &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: group.client,
			{{$node.BaseNodeName}}: &v,
		}
	}
	return
}

type {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} struct {
	client *Clientset
	*{{$node.GroupBaseImport}}
}

// Delete removes obj and all it's children from the database.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete(ctx context.Context) error {
	err := obj.client.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Update(ctx context.Context) error {
	result, err := obj.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().
		Update(ctx, obj.{{$node.BaseNodeName}}, metav1.UpdateOptions{})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result
	return nil
}

{{ if .Parent.HasParent }}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetParent(ctx context.Context) (result *{{$node.Parent.SimpleGroupTypeName}}{{$node.Parent.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.Parent.CrdName}}", obj.Labels, obj.Labels["{{$node.Parent.CrdName}}"])
	return obj.client.{{$node.Parent.SimpleGroupTypeName}}().Get{{$node.Parent.BaseNodeName}}ByName(ctx, hashedName)
}
{{ end }}

{{ if not .Parent.HasParent }}
func (c *Clientset) {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(displayName string) *{{$node.GroupResourceType}}Chainer {
	parentLabels := make(map[string]string)
	parentLabels["{{$node.CrdName}}"] = displayName
	return &{{$node.GroupResourceType}}Chainer{
		client:       c,
		name:  displayName,
		parentLabels: parentLabels,
	}
}

// Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context, displayName string) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, displayName)
	return c.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
}

// Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context,
		objToCreate *{{$node.GroupBaseImport}}) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.{{$node.SimpleGroupTypeName}}().Create{{$node.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, displayName)
	return c.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, hashedName)
}
{{ end }}

{{ range $key, $link := .LinksAndChildren }}
{{ if $link.IsNamed }}
// GetAll{{$link.FieldName}} returns all links or children of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetAll{{$link.FieldName}}(ctx context.Context) (
		result []*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	result = make([]*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, 0, len(obj.Spec.{{$link.FieldName}}Gvk))
	for _, v := range obj.Spec.{{$link.FieldName}}Gvk {
		l, err := obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// Get{{$link.FieldName}} returns link or child which has given displayName
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context,
		displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	l, ok := obj.Spec.{{$link.FieldName}}Gvk[displayName]
	if !ok {
		return nil, fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, l.Name)
	return
}

{{ else }}
// Get{{$link.FieldName}} returns child or link of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context) (
		result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if obj.Spec.{{$link.FieldName}}Gvk != nil {
		return obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, obj.Spec.{{$link.FieldName}}Gvk.Name)
	}
	return
}

{{ end }}
{{ end }}

{{ range $key, $link := .Children }}
// Add{{$link.FieldName}} calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Add{{$link.FieldName}}(ctx context.Context,
	objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["{{$node.CrdName}}"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["{{$node.CrdName}}"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
	updatedObj, getErr :=  obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if getErr == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
{{ if $link.IsNamed }}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete{{$link.FieldName}}(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.{{$link.FieldName}}Gvk[displayName]
	if !ok {
		return fmt.Errorf("object %s doesn't have child %s", obj.DisplayName(), displayName)
	}
	err = obj.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}
{{ else}}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete{{$link.FieldName}}(ctx context.Context) (err error) {
	if obj.Spec.{{$link.FieldName}}Gvk != nil {
		err = obj.client.
		{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, obj.Spec.{{$link.FieldName}}Gvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
	{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}
{{ end }}
{{ end }}

{{ range $key, $link := .Links }}
// Link{{$link.FieldName}} links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Link{{$link.FieldName}}(ctx context.Context,
	linkToAdd *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}) (error) {
	{{ if $link.IsNamed }}
	payload := "{\"spec\": {\"{{$link.FieldNameGvk}}\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"{{$link.Kind}}\", \"group\": \"{{$link.Group}}\"}}}}"
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/{{$link.FieldNameGvk}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$link.Group}}",
		Kind:  "{{$link.Kind}}",
		Name:  linkToAdd.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ end }}
	obj.{{$node.BaseNodeName}} = result
	return nil
}

// Unlink{{$link.FieldName}} unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Unlink{{$link.FieldName}}(ctx context.Context{{if $link.IsNamed}},
	linkToRemove *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}{{end}}) (err error) {
	var patch Patch
	{{if $link.IsNamed}}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}/" + linkToRemove.DisplayName(),
	}
	{{ else }}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result
	return nil

}
{{ end }}

type {{$node.GroupResourceType}}Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

{{ range $key, $link := .Children }}
func (c *{{$node.GroupResourceType}}Chainer) {{$link.FieldName}}(name string) *{{$link.GroupResourceType}}Chainer {
	parentLabels := c.parentLabels
	parentLabels["{{$link.CrdName}}"] = name
	return &{{$link.GroupResourceType}}Chainer{
		client: c.client,
		name: name,
		parentLabels: parentLabels,
	}
}

// Get{{$link.FieldName}} calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *{{$node.GroupResourceType}}Chainer) Get{{$link.FieldName}}(ctx context.Context, displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, displayName)
	return c.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *{{$node.GroupResourceType}}Chainer) Add{{$link.FieldName}}(ctx context.Context,
	objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *{{$node.GroupResourceType}}Chainer) Delete{{$link.FieldName}}(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, name)
	return c.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

{{ end }}

{{ end }}