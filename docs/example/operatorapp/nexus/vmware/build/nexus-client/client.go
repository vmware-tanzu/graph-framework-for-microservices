// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"

	baseClientset "vmware/build/client/clientset/versioned"
	fakeBaseClienset "vmware/build/client/clientset/versioned/fake"
	"vmware/build/common"
	"vmware/build/helper"

	baseengineeringvmwareorgv1 "vmware/build/apis/engineering.vmware.org/v1"
	basehrvmwareorgv1 "vmware/build/apis/hr.vmware.org/v1"
	basemanagementvmwareorgv1 "vmware/build/apis/management.vmware.org/v1"
	baseorgchartvmwareorgv1 "vmware/build/apis/orgchart.vmware.org/v1"
	baserolevmwareorgv1 "vmware/build/apis/role.vmware.org/v1"
)

type Clientset struct {
	baseClient          baseClientset.Interface
	orgchartVmwareV1    *OrgchartVmwareV1
	engineeringVmwareV1 *EngineeringVmwareV1
	hrVmwareV1          *HrVmwareV1
	managementVmwareV1  *ManagementVmwareV1
	roleVmwareV1        *RoleVmwareV1
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.orgchartVmwareV1 = newOrgchartVmwareV1(client)
	client.engineeringVmwareV1 = newEngineeringVmwareV1(client)
	client.hrVmwareV1 = newHrVmwareV1(client)
	client.managementVmwareV1 = newManagementVmwareV1(client)
	client.roleVmwareV1 = newRoleVmwareV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.orgchartVmwareV1 = newOrgchartVmwareV1(client)
	client.engineeringVmwareV1 = newEngineeringVmwareV1(client)
	client.hrVmwareV1 = newHrVmwareV1(client)
	client.managementVmwareV1 = newManagementVmwareV1(client)
	client.roleVmwareV1 = newRoleVmwareV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Orgchart() *OrgchartVmwareV1 {
	return c.orgchartVmwareV1
}
func (c *Clientset) Engineering() *EngineeringVmwareV1 {
	return c.engineeringVmwareV1
}
func (c *Clientset) Hr() *HrVmwareV1 {
	return c.hrVmwareV1
}
func (c *Clientset) Management() *ManagementVmwareV1 {
	return c.managementVmwareV1
}
func (c *Clientset) Role() *RoleVmwareV1 {
	return c.roleVmwareV1
}

type OrgchartVmwareV1 struct {
	client *Clientset
}

func newOrgchartVmwareV1(client *Clientset) *OrgchartVmwareV1 {
	return &OrgchartVmwareV1{
		client: client,
	}
}

type EngineeringVmwareV1 struct {
	client *Clientset
}

func newEngineeringVmwareV1(client *Clientset) *EngineeringVmwareV1 {
	return &EngineeringVmwareV1{
		client: client,
	}
}

type HrVmwareV1 struct {
	client *Clientset
}

func newHrVmwareV1(client *Clientset) *HrVmwareV1 {
	return &HrVmwareV1{
		client: client,
	}
}

type ManagementVmwareV1 struct {
	client *Clientset
}

func newManagementVmwareV1(client *Clientset) *ManagementVmwareV1 {
	return &ManagementVmwareV1{
		client: client,
	}
}

type RoleVmwareV1 struct {
	client *Clientset
}

func newRoleVmwareV1(client *Clientset) *RoleVmwareV1 {
	return &RoleVmwareV1{
		client: client,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgchartVmwareV1) GetRootByName(ctx context.Context, hashedName string) (*OrgchartRoot, error) {
	result, err := group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &OrgchartRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *OrgchartVmwareV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.CEOGvk != nil {
		err := group.client.
			Management().
			DeleteLeaderByName(ctx, result.Spec.CEOGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.ExecutiveRoleGvk != nil {
		err := group.client.
			Role().
			DeleteExecutiveByName(ctx, result.Spec.ExecutiveRoleGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.EmployeeRoleGvk != nil {
		err := group.client.
			Role().
			DeleteEmployeeByName(ctx, result.Spec.EmployeeRoleGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *OrgchartVmwareV1) CreateRootByName(ctx context.Context,
	objToCreate *baseorgchartvmwareorgv1.Root) (*OrgchartRoot, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.CEOGvk = nil
	objToCreate.Spec.ExecutiveRoleGvk = nil
	objToCreate.Spec.EmployeeRoleGvk = nil

	result, err := group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &OrgchartRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *OrgchartVmwareV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baseorgchartvmwareorgv1.Root) (*OrgchartRoot, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			OrgchartVmwareV1().
			Roots().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &OrgchartRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *OrgchartVmwareV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*OrgchartRoot, err error) {
	list, err := group.client.baseClient.OrgchartVmwareV1().
		Roots().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*OrgchartRoot, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &OrgchartRoot{
			client: group.client,
			Root:   &item,
		}
	}
	return
}

type OrgchartRoot struct {
	client *Clientset
	*baseorgchartvmwareorgv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *OrgchartRoot) Delete(ctx context.Context) error {
	err := obj.client.Orgchart().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *OrgchartRoot) Update(ctx context.Context) error {
	result, err := obj.client.Orgchart().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetOrgchartRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetOrgchartRoot(ctx context.Context) (result *OrgchartRoot, err error) {
	hashedName := helper.GetHashedName("roots.orgchart.vmware.org", nil, helper.DEFAULT_KEY)
	return c.Orgchart().GetRootByName(ctx, hashedName)
}

func (c *Clientset) OrgchartRoot() *rootOrgchartVmwareV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.orgchart.vmware.org"] = helper.DEFAULT_KEY
	return &rootOrgchartVmwareV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddOrgchartRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddOrgchartRoot(ctx context.Context,
	objToCreate *baseorgchartvmwareorgv1.Root) (result *OrgchartRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Orgchart().CreateRootByName(ctx, objToCreate)
}

// DeleteOrgchartRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteOrgchartRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.orgchart.vmware.org", nil, helper.DEFAULT_KEY)
	return c.Orgchart().DeleteRootByName(ctx, hashedName)
}

// GetCEO returns child of given type
func (obj *OrgchartRoot) GetCEO(ctx context.Context) (
	result *ManagementLeader, err error) {
	if obj.Spec.CEOGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Orgchart.Root", "CEO")
	}
	return obj.client.Management().GetLeaderByName(ctx, obj.Spec.CEOGvk.Name)
}

// AddCEO calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *OrgchartRoot) AddCEO(ctx context.Context,
	objToCreate *basemanagementvmwareorgv1.Leader) (result *ManagementLeader, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.orgchart.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.orgchart.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Management().CreateLeaderByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Orgchart().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteCEO calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *OrgchartRoot) DeleteCEO(ctx context.Context) (err error) {
	if obj.Spec.CEOGvk != nil {
		err = obj.client.
			Management().DeleteLeaderByName(ctx, obj.Spec.CEOGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Orgchart().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// GetExecutiveRole returns child of given type
func (obj *OrgchartRoot) GetExecutiveRole(ctx context.Context) (
	result *RoleExecutive, err error) {
	if obj.Spec.ExecutiveRoleGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Orgchart.Root", "ExecutiveRole")
	}
	return obj.client.Role().GetExecutiveByName(ctx, obj.Spec.ExecutiveRoleGvk.Name)
}

// AddExecutiveRole calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *OrgchartRoot) AddExecutiveRole(ctx context.Context,
	objToCreate *baserolevmwareorgv1.Executive) (result *RoleExecutive, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.orgchart.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.orgchart.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Role().CreateExecutiveByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Orgchart().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteExecutiveRole calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *OrgchartRoot) DeleteExecutiveRole(ctx context.Context) (err error) {
	if obj.Spec.ExecutiveRoleGvk != nil {
		err = obj.client.
			Role().DeleteExecutiveByName(ctx, obj.Spec.ExecutiveRoleGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Orgchart().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// GetEmployeeRole returns child of given type
func (obj *OrgchartRoot) GetEmployeeRole(ctx context.Context) (
	result *RoleEmployee, err error) {
	if obj.Spec.EmployeeRoleGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Orgchart.Root", "EmployeeRole")
	}
	return obj.client.Role().GetEmployeeByName(ctx, obj.Spec.EmployeeRoleGvk.Name)
}

// AddEmployeeRole calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *OrgchartRoot) AddEmployeeRole(ctx context.Context,
	objToCreate *baserolevmwareorgv1.Employee) (result *RoleEmployee, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.orgchart.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.orgchart.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Role().CreateEmployeeByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Orgchart().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteEmployeeRole calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *OrgchartRoot) DeleteEmployeeRole(ctx context.Context) (err error) {
	if obj.Spec.EmployeeRoleGvk != nil {
		err = obj.client.
			Role().DeleteEmployeeByName(ctx, obj.Spec.EmployeeRoleGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Orgchart().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootOrgchartVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootOrgchartVmwareV1Chainer) CEO() *leaderManagementVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["leaders.management.vmware.org"] = helper.DEFAULT_KEY
	return &leaderManagementVmwareV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetCEO calculates hashed name of the object based on it's parents and returns the object
func (c *rootOrgchartVmwareV1Chainer) GetCEO(ctx context.Context) (result *ManagementLeader, err error) {
	hashedName := helper.GetHashedName("leaders.management.vmware.org", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Management().GetLeaderByName(ctx, hashedName)
}

// AddCEO calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootOrgchartVmwareV1Chainer) AddCEO(ctx context.Context,
	objToCreate *basemanagementvmwareorgv1.Leader) (result *ManagementLeader, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("leaders.management.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Management().CreateLeaderByName(ctx, objToCreate)
}

// DeleteCEO calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootOrgchartVmwareV1Chainer) DeleteCEO(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("leaders.management.vmware.org", c.parentLabels, name)
	return c.client.Management().DeleteLeaderByName(ctx, hashedName)
}

func (c *rootOrgchartVmwareV1Chainer) ExecutiveRole(name string) *executiveRoleVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["executives.role.vmware.org"] = name
	return &executiveRoleVmwareV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetExecutiveRole calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootOrgchartVmwareV1Chainer) GetExecutiveRole(ctx context.Context, displayName string) (result *RoleExecutive, err error) {
	hashedName := helper.GetHashedName("executives.role.vmware.org", c.parentLabels, displayName)
	return c.client.Role().GetExecutiveByName(ctx, hashedName)
}

// AddExecutiveRole calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootOrgchartVmwareV1Chainer) AddExecutiveRole(ctx context.Context,
	objToCreate *baserolevmwareorgv1.Executive) (result *RoleExecutive, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("executives.role.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Role().CreateExecutiveByName(ctx, objToCreate)
}

// DeleteExecutiveRole calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootOrgchartVmwareV1Chainer) DeleteExecutiveRole(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("executives.role.vmware.org", c.parentLabels, name)
	return c.client.Role().DeleteExecutiveByName(ctx, hashedName)
}

func (c *rootOrgchartVmwareV1Chainer) EmployeeRole(name string) *employeeRoleVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["employees.role.vmware.org"] = name
	return &employeeRoleVmwareV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEmployeeRole calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootOrgchartVmwareV1Chainer) GetEmployeeRole(ctx context.Context, displayName string) (result *RoleEmployee, err error) {
	hashedName := helper.GetHashedName("employees.role.vmware.org", c.parentLabels, displayName)
	return c.client.Role().GetEmployeeByName(ctx, hashedName)
}

// AddEmployeeRole calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootOrgchartVmwareV1Chainer) AddEmployeeRole(ctx context.Context,
	objToCreate *baserolevmwareorgv1.Employee) (result *RoleEmployee, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("employees.role.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Role().CreateEmployeeByName(ctx, objToCreate)
}

// DeleteEmployeeRole calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootOrgchartVmwareV1Chainer) DeleteEmployeeRole(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("employees.role.vmware.org", c.parentLabels, name)
	return c.client.Role().DeleteEmployeeByName(ctx, hashedName)
}

// GetDevByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EngineeringVmwareV1) GetDevByName(ctx context.Context, hashedName string) (*EngineeringDev, error) {
	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Devs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &EngineeringDev{
		client: group.client,
		Dev:    result,
	}, nil
}

// DeleteDevByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *EngineeringVmwareV1) DeleteDevByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Devs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		EngineeringVmwareV1().
		Devs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/developersGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["mgrs.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("mgrs.management.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDevByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *EngineeringVmwareV1) CreateDevByName(ctx context.Context,
	objToCreate *baseengineeringvmwareorgv1.Dev) (*EngineeringDev, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.RoleGvk = nil

	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Devs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["mgrs.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("mgrs.management.vmware.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/developersGvk",
		Value: baseengineeringvmwareorgv1.Child{
			Group: "engineering.vmware.org",
			Kind:  "Dev",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &EngineeringDev{
		client: group.client,
		Dev:    result,
	}, nil
}

// UpdateDevByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *EngineeringVmwareV1) UpdateDevByName(ctx context.Context,
	objToUpdate *baseengineeringvmwareorgv1.Dev) (*EngineeringDev, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			EngineeringVmwareV1().
			Devs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueEmployeeID :=
		objToUpdate.Spec.EmployeeID
	patchOpEmployeeID := PatchOp{
		Op:    "replace",
		Path:  "/spec/employeeID",
		Value: patchValueEmployeeID,
	}
	patch = append(patch, patchOpEmployeeID)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Devs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &EngineeringDev{
		client: group.client,
		Dev:    result,
	}, nil
}

// ListDevs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *EngineeringVmwareV1) ListDevs(ctx context.Context,
	opts metav1.ListOptions) (result []*EngineeringDev, err error) {
	list, err := group.client.baseClient.EngineeringVmwareV1().
		Devs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*EngineeringDev, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &EngineeringDev{
			client: group.client,
			Dev:    &item,
		}
	}
	return
}

type EngineeringDev struct {
	client *Clientset
	*baseengineeringvmwareorgv1.Dev
}

// Delete removes obj and all it's children from the database.
func (obj *EngineeringDev) Delete(ctx context.Context) error {
	err := obj.client.Engineering().DeleteDevByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Dev = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *EngineeringDev) Update(ctx context.Context) error {
	result, err := obj.client.Engineering().UpdateDevByName(ctx, obj.Dev)
	if err != nil {
		return err
	}
	obj.Dev = result.Dev
	return nil
}

func (obj *EngineeringDev) GetParent(ctx context.Context) (result *ManagementMgr, err error) {
	hashedName := helper.GetHashedName("mgrs.management.vmware.org", obj.Labels, obj.Labels["mgrs.management.vmware.org"])
	return obj.client.Management().GetMgrByName(ctx, hashedName)
}

// GetRole returns link of given type
func (obj *EngineeringDev) GetRole(ctx context.Context) (
	result *RoleEmployee, err error) {
	if obj.Spec.RoleGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Engineering.Dev", "Role")
	}
	return obj.client.Role().GetEmployeeByName(ctx, obj.Spec.RoleGvk.Name)
}

// LinkRole links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *EngineeringDev) LinkRole(ctx context.Context,
	linkToAdd *RoleEmployee) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/roleGvk",
		Value: baseengineeringvmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Employee",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.EngineeringVmwareV1().Devs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Dev = result
	return nil
}

// UnlinkRole unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *EngineeringDev) UnlinkRole(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/roleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.EngineeringVmwareV1().Devs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Dev = result
	return nil

}

type devEngineeringVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetOperationsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EngineeringVmwareV1) GetOperationsByName(ctx context.Context, hashedName string) (*EngineeringOperations, error) {
	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Operationses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &EngineeringOperations{
		client:     group.client,
		Operations: result,
	}, nil
}

// DeleteOperationsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *EngineeringVmwareV1) DeleteOperationsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Operationses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		EngineeringVmwareV1().
		Operationses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/opsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["mgrs.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("mgrs.management.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateOperationsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *EngineeringVmwareV1) CreateOperationsByName(ctx context.Context,
	objToCreate *baseengineeringvmwareorgv1.Operations) (*EngineeringOperations, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.RoleGvk = nil

	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Operationses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["mgrs.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("mgrs.management.vmware.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/opsGvk",
		Value: baseengineeringvmwareorgv1.Child{
			Group: "engineering.vmware.org",
			Kind:  "Operations",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &EngineeringOperations{
		client:     group.client,
		Operations: result,
	}, nil
}

// UpdateOperationsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *EngineeringVmwareV1) UpdateOperationsByName(ctx context.Context,
	objToUpdate *baseengineeringvmwareorgv1.Operations) (*EngineeringOperations, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			EngineeringVmwareV1().
			Operationses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueEmployeeID :=
		objToUpdate.Spec.EmployeeID
	patchOpEmployeeID := PatchOp{
		Op:    "replace",
		Path:  "/spec/employeeID",
		Value: patchValueEmployeeID,
	}
	patch = append(patch, patchOpEmployeeID)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		EngineeringVmwareV1().
		Operationses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &EngineeringOperations{
		client:     group.client,
		Operations: result,
	}, nil
}

// ListOperationses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *EngineeringVmwareV1) ListOperationses(ctx context.Context,
	opts metav1.ListOptions) (result []*EngineeringOperations, err error) {
	list, err := group.client.baseClient.EngineeringVmwareV1().
		Operationses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*EngineeringOperations, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &EngineeringOperations{
			client:     group.client,
			Operations: &item,
		}
	}
	return
}

type EngineeringOperations struct {
	client *Clientset
	*baseengineeringvmwareorgv1.Operations
}

// Delete removes obj and all it's children from the database.
func (obj *EngineeringOperations) Delete(ctx context.Context) error {
	err := obj.client.Engineering().DeleteOperationsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Operations = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *EngineeringOperations) Update(ctx context.Context) error {
	result, err := obj.client.Engineering().UpdateOperationsByName(ctx, obj.Operations)
	if err != nil {
		return err
	}
	obj.Operations = result.Operations
	return nil
}

func (obj *EngineeringOperations) GetParent(ctx context.Context) (result *ManagementMgr, err error) {
	hashedName := helper.GetHashedName("mgrs.management.vmware.org", obj.Labels, obj.Labels["mgrs.management.vmware.org"])
	return obj.client.Management().GetMgrByName(ctx, hashedName)
}

// GetRole returns link of given type
func (obj *EngineeringOperations) GetRole(ctx context.Context) (
	result *RoleEmployee, err error) {
	if obj.Spec.RoleGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Engineering.Operations", "Role")
	}
	return obj.client.Role().GetEmployeeByName(ctx, obj.Spec.RoleGvk.Name)
}

// LinkRole links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *EngineeringOperations) LinkRole(ctx context.Context,
	linkToAdd *RoleEmployee) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/roleGvk",
		Value: baseengineeringvmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Employee",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.EngineeringVmwareV1().Operationses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Operations = result
	return nil
}

// UnlinkRole unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *EngineeringOperations) UnlinkRole(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/roleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.EngineeringVmwareV1().Operationses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Operations = result
	return nil

}

type operationsEngineeringVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetHumanResourcesByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *HrVmwareV1) GetHumanResourcesByName(ctx context.Context, hashedName string) (*HrHumanResources, error) {
	result, err := group.client.baseClient.
		HrVmwareV1().
		HumanResourceses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &HrHumanResources{
		client:         group.client,
		HumanResources: result,
	}, nil
}

// DeleteHumanResourcesByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *HrVmwareV1) DeleteHumanResourcesByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		HrVmwareV1().
		HumanResourceses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		HrVmwareV1().
		HumanResourceses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/hRGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["leaders.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("leaders.management.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateHumanResourcesByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *HrVmwareV1) CreateHumanResourcesByName(ctx context.Context,
	objToCreate *basehrvmwareorgv1.HumanResources) (*HrHumanResources, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.RoleGvk = nil

	result, err := group.client.baseClient.
		HrVmwareV1().
		HumanResourceses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["leaders.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("leaders.management.vmware.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/hRGvk",
		Value: basehrvmwareorgv1.Child{
			Group: "hr.vmware.org",
			Kind:  "HumanResources",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &HrHumanResources{
		client:         group.client,
		HumanResources: result,
	}, nil
}

// UpdateHumanResourcesByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *HrVmwareV1) UpdateHumanResourcesByName(ctx context.Context,
	objToUpdate *basehrvmwareorgv1.HumanResources) (*HrHumanResources, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			HrVmwareV1().
			HumanResourceses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueEmployeeID :=
		objToUpdate.Spec.EmployeeID
	patchOpEmployeeID := PatchOp{
		Op:    "replace",
		Path:  "/spec/employeeID",
		Value: patchValueEmployeeID,
	}
	patch = append(patch, patchOpEmployeeID)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		HrVmwareV1().
		HumanResourceses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &HrHumanResources{
		client:         group.client,
		HumanResources: result,
	}, nil
}

// ListHumanResourceses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *HrVmwareV1) ListHumanResourceses(ctx context.Context,
	opts metav1.ListOptions) (result []*HrHumanResources, err error) {
	list, err := group.client.baseClient.HrVmwareV1().
		HumanResourceses().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*HrHumanResources, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &HrHumanResources{
			client:         group.client,
			HumanResources: &item,
		}
	}
	return
}

type HrHumanResources struct {
	client *Clientset
	*basehrvmwareorgv1.HumanResources
}

// Delete removes obj and all it's children from the database.
func (obj *HrHumanResources) Delete(ctx context.Context) error {
	err := obj.client.Hr().DeleteHumanResourcesByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.HumanResources = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *HrHumanResources) Update(ctx context.Context) error {
	result, err := obj.client.Hr().UpdateHumanResourcesByName(ctx, obj.HumanResources)
	if err != nil {
		return err
	}
	obj.HumanResources = result.HumanResources
	return nil
}

func (obj *HrHumanResources) GetParent(ctx context.Context) (result *ManagementLeader, err error) {
	hashedName := helper.GetHashedName("leaders.management.vmware.org", obj.Labels, obj.Labels["leaders.management.vmware.org"])
	return obj.client.Management().GetLeaderByName(ctx, hashedName)
}

// GetRole returns link of given type
func (obj *HrHumanResources) GetRole(ctx context.Context) (
	result *RoleEmployee, err error) {
	if obj.Spec.RoleGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Hr.HumanResources", "Role")
	}
	return obj.client.Role().GetEmployeeByName(ctx, obj.Spec.RoleGvk.Name)
}

// LinkRole links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *HrHumanResources) LinkRole(ctx context.Context,
	linkToAdd *RoleEmployee) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/roleGvk",
		Value: basehrvmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Employee",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.HrVmwareV1().HumanResourceses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.HumanResources = result
	return nil
}

// UnlinkRole unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *HrHumanResources) UnlinkRole(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/roleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.HrVmwareV1().HumanResourceses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.HumanResources = result
	return nil

}

type humanresourcesHrVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetLeaderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ManagementVmwareV1) GetLeaderByName(ctx context.Context, hashedName string) (*ManagementLeader, error) {
	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ManagementLeader{
		client: group.client,
		Leader: result,
	}, nil
}

// DeleteLeaderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ManagementVmwareV1) DeleteLeaderByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.EngManagersGvk {
		err := group.client.
			Management().DeleteMgrByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.HRGvk != nil {
		err := group.client.
			Hr().
			DeleteHumanResourcesByName(ctx, result.Spec.HRGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/cEOGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.orgchart.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.orgchart.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateLeaderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ManagementVmwareV1) CreateLeaderByName(ctx context.Context,
	objToCreate *basemanagementvmwareorgv1.Leader) (*ManagementLeader, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.EngManagersGvk = nil
	objToCreate.Spec.HRGvk = nil
	objToCreate.Spec.RoleGvk = nil

	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.orgchart.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.orgchart.vmware.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/cEOGvk",
		Value: basemanagementvmwareorgv1.Child{
			Group: "management.vmware.org",
			Kind:  "Leader",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ManagementLeader{
		client: group.client,
		Leader: result,
	}, nil
}

// SetLeaderStatusByName sets user defined status
func (group *ManagementVmwareV1) SetLeaderStatusByName(ctx context.Context,
	objToUpdate *basemanagementvmwareorgv1.Leader, status *basemanagementvmwareorgv1.LeaderState) (*ManagementLeader, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/status",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &ManagementLeader{
		client: group.client,
		Leader: result,
	}, nil
}

// UpdateLeaderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ManagementVmwareV1) UpdateLeaderByName(ctx context.Context,
	objToUpdate *basemanagementvmwareorgv1.Leader) (*ManagementLeader, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ManagementVmwareV1().
			Leaders().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDesignation :=
		objToUpdate.Spec.Designation
	patchOpDesignation := PatchOp{
		Op:    "replace",
		Path:  "/spec/designation",
		Value: patchValueDesignation,
	}
	patch = append(patch, patchOpDesignation)

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueEmployeeID :=
		objToUpdate.Spec.EmployeeID
	patchOpEmployeeID := PatchOp{
		Op:    "replace",
		Path:  "/spec/employeeID",
		Value: patchValueEmployeeID,
	}
	patch = append(patch, patchOpEmployeeID)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ManagementLeader{
		client: group.client,
		Leader: result,
	}, nil
}

// ListLeaders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ManagementVmwareV1) ListLeaders(ctx context.Context,
	opts metav1.ListOptions) (result []*ManagementLeader, err error) {
	list, err := group.client.baseClient.ManagementVmwareV1().
		Leaders().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ManagementLeader, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &ManagementLeader{
			client: group.client,
			Leader: &item,
		}
	}
	return
}

type ManagementLeader struct {
	client *Clientset
	*basemanagementvmwareorgv1.Leader
}

// Delete removes obj and all it's children from the database.
func (obj *ManagementLeader) Delete(ctx context.Context) error {
	err := obj.client.Management().DeleteLeaderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Leader = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ManagementLeader) Update(ctx context.Context) error {
	result, err := obj.client.Management().UpdateLeaderByName(ctx, obj.Leader)
	if err != nil {
		return err
	}
	obj.Leader = result.Leader
	return nil
}

// SetStatus sets user defined status
func (obj *ManagementLeader) SetStatus(ctx context.Context, status *basemanagementvmwareorgv1.LeaderState) error {
	result, err := obj.client.Management().SetLeaderStatusByName(ctx, obj.Leader, status)
	if err != nil {
		return err
	}
	obj.Leader = result.Leader
	return nil
}

// GetStatus to get user defined status
func (obj *ManagementLeader) GetStatus(ctx context.Context) (*basemanagementvmwareorgv1.LeaderState, error) {
	getObj, err := obj.client.Management().GetLeaderByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *ManagementLeader) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Management().SetLeaderStatusByName(ctx, obj.Leader, &basemanagementvmwareorgv1.LeaderState{})
	if err != nil {
		return err
	}
	obj.Leader = result.Leader
	return nil
}

func (obj *ManagementLeader) GetParent(ctx context.Context) (result *OrgchartRoot, err error) {
	hashedName := helper.GetHashedName("roots.orgchart.vmware.org", obj.Labels, obj.Labels["roots.orgchart.vmware.org"])
	return obj.client.Orgchart().GetRootByName(ctx, hashedName)
}

// GetAllEngManagers returns all children of given type
func (obj *ManagementLeader) GetAllEngManagers(ctx context.Context) (
	result []*ManagementMgr, err error) {
	result = make([]*ManagementMgr, 0, len(obj.Spec.EngManagersGvk))
	for _, v := range obj.Spec.EngManagersGvk {
		l, err := obj.client.Management().GetMgrByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEngManagers returns child which has given displayName
func (obj *ManagementLeader) GetEngManagers(ctx context.Context,
	displayName string) (result *ManagementMgr, err error) {
	l, ok := obj.Spec.EngManagersGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Management.Leader", "EngManagers", displayName)
	}
	result, err = obj.client.Management().GetMgrByName(ctx, l.Name)
	return
}

// AddEngManagers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ManagementLeader) AddEngManagers(ctx context.Context,
	objToCreate *basemanagementvmwareorgv1.Mgr) (result *ManagementMgr, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["leaders.management.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["leaders.management.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Management().CreateMgrByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Management().GetLeaderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Leader = updatedObj.Leader
	}
	return
}

// DeleteEngManagers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ManagementLeader) DeleteEngManagers(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.EngManagersGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Management.Leader", "EngManagers", displayName)
	}
	err = obj.client.Management().DeleteMgrByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Management().GetLeaderByName(ctx, obj.GetName())
	if err == nil {
		obj.Leader = updatedObj.Leader
	}
	return
}

// GetHR returns child of given type
func (obj *ManagementLeader) GetHR(ctx context.Context) (
	result *HrHumanResources, err error) {
	if obj.Spec.HRGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Management.Leader", "HR")
	}
	return obj.client.Hr().GetHumanResourcesByName(ctx, obj.Spec.HRGvk.Name)
}

// AddHR calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ManagementLeader) AddHR(ctx context.Context,
	objToCreate *basehrvmwareorgv1.HumanResources) (result *HrHumanResources, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["leaders.management.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["leaders.management.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Hr().CreateHumanResourcesByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Management().GetLeaderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Leader = updatedObj.Leader
	}
	return
}

// DeleteHR calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ManagementLeader) DeleteHR(ctx context.Context) (err error) {
	if obj.Spec.HRGvk != nil {
		err = obj.client.
			Hr().DeleteHumanResourcesByName(ctx, obj.Spec.HRGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Management().GetLeaderByName(ctx, obj.GetName())
	if err == nil {
		obj.Leader = updatedObj.Leader
	}
	return
}

// GetRole returns link of given type
func (obj *ManagementLeader) GetRole(ctx context.Context) (
	result *RoleExecutive, err error) {
	if obj.Spec.RoleGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Management.Leader", "Role")
	}
	return obj.client.Role().GetExecutiveByName(ctx, obj.Spec.RoleGvk.Name)
}

// LinkRole links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *ManagementLeader) LinkRole(ctx context.Context,
	linkToAdd *RoleExecutive) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/roleGvk",
		Value: basemanagementvmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Executive",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ManagementVmwareV1().Leaders().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Leader = result
	return nil
}

// UnlinkRole unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *ManagementLeader) UnlinkRole(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/roleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ManagementVmwareV1().Leaders().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Leader = result
	return nil

}

type leaderManagementVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// ClearStatus to clear user defined status
func (c *leaderManagementVmwareV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("leaders.management.vmware.org", c.parentLabels, c.name)
	obj, err := c.client.Management().GetLeaderByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Management().SetLeaderStatusByName(ctx, obj.Leader, nil)
	return err
}

// GetStatus to get user defined status
func (c *leaderManagementVmwareV1Chainer) GetStatus(ctx context.Context) (result *basemanagementvmwareorgv1.LeaderState, err error) {
	hashedName := helper.GetHashedName("leaders.management.vmware.org", c.parentLabels, c.name)
	obj, err := c.client.Management().GetLeaderByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *leaderManagementVmwareV1Chainer) SetStatus(ctx context.Context, status *basemanagementvmwareorgv1.LeaderState) (err error) {
	hashedName := helper.GetHashedName("leaders.management.vmware.org", c.parentLabels, c.name)
	obj, err := c.client.Management().GetLeaderByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Management().SetLeaderStatusByName(ctx, obj.Leader, status)
	return err
}

func (c *leaderManagementVmwareV1Chainer) EngManagers(name string) *mgrManagementVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["mgrs.management.vmware.org"] = name
	return &mgrManagementVmwareV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEngManagers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *leaderManagementVmwareV1Chainer) GetEngManagers(ctx context.Context, displayName string) (result *ManagementMgr, err error) {
	hashedName := helper.GetHashedName("mgrs.management.vmware.org", c.parentLabels, displayName)
	return c.client.Management().GetMgrByName(ctx, hashedName)
}

// AddEngManagers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *leaderManagementVmwareV1Chainer) AddEngManagers(ctx context.Context,
	objToCreate *basemanagementvmwareorgv1.Mgr) (result *ManagementMgr, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("mgrs.management.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Management().CreateMgrByName(ctx, objToCreate)
}

// DeleteEngManagers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *leaderManagementVmwareV1Chainer) DeleteEngManagers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("mgrs.management.vmware.org", c.parentLabels, name)
	return c.client.Management().DeleteMgrByName(ctx, hashedName)
}

func (c *leaderManagementVmwareV1Chainer) HR(name string) *humanresourcesHrVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["humanresourceses.hr.vmware.org"] = name
	return &humanresourcesHrVmwareV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetHR calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *leaderManagementVmwareV1Chainer) GetHR(ctx context.Context, displayName string) (result *HrHumanResources, err error) {
	hashedName := helper.GetHashedName("humanresourceses.hr.vmware.org", c.parentLabels, displayName)
	return c.client.Hr().GetHumanResourcesByName(ctx, hashedName)
}

// AddHR calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *leaderManagementVmwareV1Chainer) AddHR(ctx context.Context,
	objToCreate *basehrvmwareorgv1.HumanResources) (result *HrHumanResources, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("humanresourceses.hr.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Hr().CreateHumanResourcesByName(ctx, objToCreate)
}

// DeleteHR calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *leaderManagementVmwareV1Chainer) DeleteHR(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("humanresourceses.hr.vmware.org", c.parentLabels, name)
	return c.client.Hr().DeleteHumanResourcesByName(ctx, hashedName)
}

// GetMgrByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ManagementVmwareV1) GetMgrByName(ctx context.Context, hashedName string) (*ManagementMgr, error) {
	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &ManagementMgr{
		client: group.client,
		Mgr:    result,
	}, nil
}

// DeleteMgrByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ManagementVmwareV1) DeleteMgrByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.DevelopersGvk != nil {
		err := group.client.
			Engineering().
			DeleteDevByName(ctx, result.Spec.DevelopersGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.OpsGvk != nil {
		err := group.client.
			Engineering().
			DeleteOperationsByName(ctx, result.Spec.OpsGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/engManagersGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["leaders.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("leaders.management.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateMgrByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ManagementVmwareV1) CreateMgrByName(ctx context.Context,
	objToCreate *basemanagementvmwareorgv1.Mgr) (*ManagementMgr, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DevelopersGvk = nil
	objToCreate.Spec.OpsGvk = nil
	objToCreate.Spec.RoleGvk = nil

	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["leaders.management.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("leaders.management.vmware.org", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"engManagersGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Mgr\", \"group\": \"management.vmware.org\"}}}}"
	_, err = group.client.baseClient.
		ManagementVmwareV1().
		Leaders().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ManagementMgr{
		client: group.client,
		Mgr:    result,
	}, nil
}

// UpdateMgrByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ManagementVmwareV1) UpdateMgrByName(ctx context.Context,
	objToUpdate *basemanagementvmwareorgv1.Mgr) (*ManagementMgr, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ManagementVmwareV1().
			Mgrs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	patchValueEmployeeID :=
		objToUpdate.Spec.EmployeeID
	patchOpEmployeeID := PatchOp{
		Op:    "replace",
		Path:  "/spec/employeeID",
		Value: patchValueEmployeeID,
	}
	patch = append(patch, patchOpEmployeeID)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ManagementVmwareV1().
		Mgrs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ManagementMgr{
		client: group.client,
		Mgr:    result,
	}, nil
}

// ListMgrs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ManagementVmwareV1) ListMgrs(ctx context.Context,
	opts metav1.ListOptions) (result []*ManagementMgr, err error) {
	list, err := group.client.baseClient.ManagementVmwareV1().
		Mgrs().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*ManagementMgr, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &ManagementMgr{
			client: group.client,
			Mgr:    &item,
		}
	}
	return
}

type ManagementMgr struct {
	client *Clientset
	*basemanagementvmwareorgv1.Mgr
}

// Delete removes obj and all it's children from the database.
func (obj *ManagementMgr) Delete(ctx context.Context) error {
	err := obj.client.Management().DeleteMgrByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Mgr = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ManagementMgr) Update(ctx context.Context) error {
	result, err := obj.client.Management().UpdateMgrByName(ctx, obj.Mgr)
	if err != nil {
		return err
	}
	obj.Mgr = result.Mgr
	return nil
}

func (obj *ManagementMgr) GetParent(ctx context.Context) (result *ManagementLeader, err error) {
	hashedName := helper.GetHashedName("leaders.management.vmware.org", obj.Labels, obj.Labels["leaders.management.vmware.org"])
	return obj.client.Management().GetLeaderByName(ctx, hashedName)
}

// GetDevelopers returns child of given type
func (obj *ManagementMgr) GetDevelopers(ctx context.Context) (
	result *EngineeringDev, err error) {
	if obj.Spec.DevelopersGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Management.Mgr", "Developers")
	}
	return obj.client.Engineering().GetDevByName(ctx, obj.Spec.DevelopersGvk.Name)
}

// AddDevelopers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ManagementMgr) AddDevelopers(ctx context.Context,
	objToCreate *baseengineeringvmwareorgv1.Dev) (result *EngineeringDev, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["mgrs.management.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["mgrs.management.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Engineering().CreateDevByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Management().GetMgrByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Mgr = updatedObj.Mgr
	}
	return
}

// DeleteDevelopers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ManagementMgr) DeleteDevelopers(ctx context.Context) (err error) {
	if obj.Spec.DevelopersGvk != nil {
		err = obj.client.
			Engineering().DeleteDevByName(ctx, obj.Spec.DevelopersGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Management().GetMgrByName(ctx, obj.GetName())
	if err == nil {
		obj.Mgr = updatedObj.Mgr
	}
	return
}

// GetOps returns child of given type
func (obj *ManagementMgr) GetOps(ctx context.Context) (
	result *EngineeringOperations, err error) {
	if obj.Spec.OpsGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Management.Mgr", "Ops")
	}
	return obj.client.Engineering().GetOperationsByName(ctx, obj.Spec.OpsGvk.Name)
}

// AddOps calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ManagementMgr) AddOps(ctx context.Context,
	objToCreate *baseengineeringvmwareorgv1.Operations) (result *EngineeringOperations, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["mgrs.management.vmware.org"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["mgrs.management.vmware.org"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Engineering().CreateOperationsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Management().GetMgrByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Mgr = updatedObj.Mgr
	}
	return
}

// DeleteOps calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ManagementMgr) DeleteOps(ctx context.Context) (err error) {
	if obj.Spec.OpsGvk != nil {
		err = obj.client.
			Engineering().DeleteOperationsByName(ctx, obj.Spec.OpsGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Management().GetMgrByName(ctx, obj.GetName())
	if err == nil {
		obj.Mgr = updatedObj.Mgr
	}
	return
}

// GetRole returns link of given type
func (obj *ManagementMgr) GetRole(ctx context.Context) (
	result *RoleEmployee, err error) {
	if obj.Spec.RoleGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Management.Mgr", "Role")
	}
	return obj.client.Role().GetEmployeeByName(ctx, obj.Spec.RoleGvk.Name)
}

// LinkRole links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *ManagementMgr) LinkRole(ctx context.Context,
	linkToAdd *RoleEmployee) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/roleGvk",
		Value: basemanagementvmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Employee",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ManagementVmwareV1().Mgrs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Mgr = result
	return nil
}

// UnlinkRole unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *ManagementMgr) UnlinkRole(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/roleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ManagementVmwareV1().Mgrs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Mgr = result
	return nil

}

type mgrManagementVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *mgrManagementVmwareV1Chainer) Developers(name string) *devEngineeringVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["devs.engineering.vmware.org"] = name
	return &devEngineeringVmwareV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDevelopers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *mgrManagementVmwareV1Chainer) GetDevelopers(ctx context.Context, displayName string) (result *EngineeringDev, err error) {
	hashedName := helper.GetHashedName("devs.engineering.vmware.org", c.parentLabels, displayName)
	return c.client.Engineering().GetDevByName(ctx, hashedName)
}

// AddDevelopers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *mgrManagementVmwareV1Chainer) AddDevelopers(ctx context.Context,
	objToCreate *baseengineeringvmwareorgv1.Dev) (result *EngineeringDev, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("devs.engineering.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Engineering().CreateDevByName(ctx, objToCreate)
}

// DeleteDevelopers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *mgrManagementVmwareV1Chainer) DeleteDevelopers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("devs.engineering.vmware.org", c.parentLabels, name)
	return c.client.Engineering().DeleteDevByName(ctx, hashedName)
}

func (c *mgrManagementVmwareV1Chainer) Ops(name string) *operationsEngineeringVmwareV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["operationses.engineering.vmware.org"] = name
	return &operationsEngineeringVmwareV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetOps calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *mgrManagementVmwareV1Chainer) GetOps(ctx context.Context, displayName string) (result *EngineeringOperations, err error) {
	hashedName := helper.GetHashedName("operationses.engineering.vmware.org", c.parentLabels, displayName)
	return c.client.Engineering().GetOperationsByName(ctx, hashedName)
}

// AddOps calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *mgrManagementVmwareV1Chainer) AddOps(ctx context.Context,
	objToCreate *baseengineeringvmwareorgv1.Operations) (result *EngineeringOperations, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("operationses.engineering.vmware.org", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Engineering().CreateOperationsByName(ctx, objToCreate)
}

// DeleteOps calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *mgrManagementVmwareV1Chainer) DeleteOps(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("operationses.engineering.vmware.org", c.parentLabels, name)
	return c.client.Engineering().DeleteOperationsByName(ctx, hashedName)
}

// GetExecutiveByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RoleVmwareV1) GetExecutiveByName(ctx context.Context, hashedName string) (*RoleExecutive, error) {
	result, err := group.client.baseClient.
		RoleVmwareV1().
		Executives().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &RoleExecutive{
		client:    group.client,
		Executive: result,
	}, nil
}

// DeleteExecutiveByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RoleVmwareV1) DeleteExecutiveByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		RoleVmwareV1().
		Executives().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		RoleVmwareV1().
		Executives().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/executiveRoleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.orgchart.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.orgchart.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateExecutiveByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RoleVmwareV1) CreateExecutiveByName(ctx context.Context,
	objToCreate *baserolevmwareorgv1.Executive) (*RoleExecutive, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		RoleVmwareV1().
		Executives().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.orgchart.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.orgchart.vmware.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/executiveRoleGvk",
		Value: baserolevmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Executive",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &RoleExecutive{
		client:    group.client,
		Executive: result,
	}, nil
}

// UpdateExecutiveByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RoleVmwareV1) UpdateExecutiveByName(ctx context.Context,
	objToUpdate *baserolevmwareorgv1.Executive) (*RoleExecutive, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			RoleVmwareV1().
			Executives().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		RoleVmwareV1().
		Executives().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &RoleExecutive{
		client:    group.client,
		Executive: result,
	}, nil
}

// ListExecutives returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RoleVmwareV1) ListExecutives(ctx context.Context,
	opts metav1.ListOptions) (result []*RoleExecutive, err error) {
	list, err := group.client.baseClient.RoleVmwareV1().
		Executives().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*RoleExecutive, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &RoleExecutive{
			client:    group.client,
			Executive: &item,
		}
	}
	return
}

type RoleExecutive struct {
	client *Clientset
	*baserolevmwareorgv1.Executive
}

// Delete removes obj and all it's children from the database.
func (obj *RoleExecutive) Delete(ctx context.Context) error {
	err := obj.client.Role().DeleteExecutiveByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Executive = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RoleExecutive) Update(ctx context.Context) error {
	result, err := obj.client.Role().UpdateExecutiveByName(ctx, obj.Executive)
	if err != nil {
		return err
	}
	obj.Executive = result.Executive
	return nil
}

func (obj *RoleExecutive) GetParent(ctx context.Context) (result *OrgchartRoot, err error) {
	hashedName := helper.GetHashedName("roots.orgchart.vmware.org", obj.Labels, obj.Labels["roots.orgchart.vmware.org"])
	return obj.client.Orgchart().GetRootByName(ctx, hashedName)
}

type executiveRoleVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

// GetEmployeeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RoleVmwareV1) GetEmployeeByName(ctx context.Context, hashedName string) (*RoleEmployee, error) {
	result, err := group.client.baseClient.
		RoleVmwareV1().
		Employees().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &RoleEmployee{
		client:   group.client,
		Employee: result,
	}, nil
}

// DeleteEmployeeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RoleVmwareV1) DeleteEmployeeByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		RoleVmwareV1().
		Employees().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		RoleVmwareV1().
		Employees().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/employeeRoleGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.orgchart.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.orgchart.vmware.org", parents, parentName)
	}
	_, err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateEmployeeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RoleVmwareV1) CreateEmployeeByName(ctx context.Context,
	objToCreate *baserolevmwareorgv1.Employee) (*RoleEmployee, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		RoleVmwareV1().
		Employees().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.orgchart.vmware.org"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.orgchart.vmware.org", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/employeeRoleGvk",
		Value: baserolevmwareorgv1.Child{
			Group: "role.vmware.org",
			Kind:  "Employee",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		OrgchartVmwareV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &RoleEmployee{
		client:   group.client,
		Employee: result,
	}, nil
}

// UpdateEmployeeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RoleVmwareV1) UpdateEmployeeByName(ctx context.Context,
	objToUpdate *baserolevmwareorgv1.Employee) (*RoleEmployee, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			RoleVmwareV1().
			Employees().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		RoleVmwareV1().
		Employees().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &RoleEmployee{
		client:   group.client,
		Employee: result,
	}, nil
}

// ListEmployees returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RoleVmwareV1) ListEmployees(ctx context.Context,
	opts metav1.ListOptions) (result []*RoleEmployee, err error) {
	list, err := group.client.baseClient.RoleVmwareV1().
		Employees().List(ctx, opts)
	if err != nil {
		return nil, err
	}
	result = make([]*RoleEmployee, len(list.Items))
	for k, v := range list.Items {
		item := v
		result[k] = &RoleEmployee{
			client:   group.client,
			Employee: &item,
		}
	}
	return
}

type RoleEmployee struct {
	client *Clientset
	*baserolevmwareorgv1.Employee
}

// Delete removes obj and all it's children from the database.
func (obj *RoleEmployee) Delete(ctx context.Context) error {
	err := obj.client.Role().DeleteEmployeeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Employee = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RoleEmployee) Update(ctx context.Context) error {
	result, err := obj.client.Role().UpdateEmployeeByName(ctx, obj.Employee)
	if err != nil {
		return err
	}
	obj.Employee = result.Employee
	return nil
}

func (obj *RoleEmployee) GetParent(ctx context.Context) (result *OrgchartRoot, err error) {
	hashedName := helper.GetHashedName("roots.orgchart.vmware.org", obj.Labels, obj.Labels["roots.orgchart.vmware.org"])
	return obj.client.Orgchart().GetRootByName(ctx, hashedName)
}

type employeeRoleVmwareV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}
