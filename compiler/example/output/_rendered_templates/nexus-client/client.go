// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"sync"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "nexustempmodule/client/clientset/versioned"
	fakeBaseClienset "nexustempmodule/client/clientset/versioned/fake"
	"nexustempmodule/common"
	"nexustempmodule/helper"

	baseconfigtsmtanzuvmwarecomv1 "nexustempmodule/apis/config.tsm.tanzu.vmware.com/v1"
	basegnstsmtanzuvmwarecomv1 "nexustempmodule/apis/gns.tsm.tanzu.vmware.com/v1"
	basepolicypkgtsmtanzuvmwarecomv1 "nexustempmodule/apis/policypkg.tsm.tanzu.vmware.com/v1"
	baseroottsmtanzuvmwarecomv1 "nexustempmodule/apis/root.tsm.tanzu.vmware.com/v1"
	baseservicegrouptsmtanzuvmwarecomv1 "nexustempmodule/apis/servicegroup.tsm.tanzu.vmware.com/v1"

	informerconfigtsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/config.tsm.tanzu.vmware.com/v1"
	informergnstsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/gns.tsm.tanzu.vmware.com/v1"
	informerpolicypkgtsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/policypkg.tsm.tanzu.vmware.com/v1"
	informerroottsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/root.tsm.tanzu.vmware.com/v1"
	informerservicegrouptsmtanzuvmwarecomv1 "nexustempmodule/client/informers/externalversions/servicegroup.tsm.tanzu.vmware.com/v1"
)

type Clientset struct {
	baseClient        baseClientset.Interface
	rootTsmV1         *RootTsmV1
	configTsmV1       *ConfigTsmV1
	gnsTsmV1          *GnsTsmV1
	servicegroupTsmV1 *ServicegroupTsmV1
	policypkgTsmV1    *PolicypkgTsmV1
}

type subscription struct {
	informer cache.SharedIndexInformer
	stop     chan struct{}
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer: informer,
		stop:     make(chan struct{}),
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "roots.root.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerroottsmtanzuvmwarecomv1.NewRootInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "configs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "footypeabcs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "domains.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "randomgnsdatas.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewRandomGnsDataInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "foos.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewFooInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "gnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "barchilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "ignorechilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "dnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "additionalgnsdatas.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewAdditionalGnsDataInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewAdditionalPolicyDataInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "randompolicydatas.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewRandomPolicyDataInformer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)
	client.servicegroupTsmV1 = newServicegroupTsmV1(client)
	client.policypkgTsmV1 = newPolicypkgTsmV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.rootTsmV1 = newRootTsmV1(client)
	client.configTsmV1 = newConfigTsmV1(client)
	client.gnsTsmV1 = newGnsTsmV1(client)
	client.servicegroupTsmV1 = newServicegroupTsmV1(client)
	client.policypkgTsmV1 = newPolicypkgTsmV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootTsmV1 {
	return c.rootTsmV1
}
func (c *Clientset) Config() *ConfigTsmV1 {
	return c.configTsmV1
}
func (c *Clientset) Gns() *GnsTsmV1 {
	return c.gnsTsmV1
}
func (c *Clientset) Servicegroup() *ServicegroupTsmV1 {
	return c.servicegroupTsmV1
}
func (c *Clientset) Policypkg() *PolicypkgTsmV1 {
	return c.policypkgTsmV1
}

type RootTsmV1 struct {
	client *Clientset
}

func newRootTsmV1(client *Clientset) *RootTsmV1 {
	return &RootTsmV1{
		client: client,
	}
}

type ConfigTsmV1 struct {
	client *Clientset
}

func newConfigTsmV1(client *Clientset) *ConfigTsmV1 {
	return &ConfigTsmV1{
		client: client,
	}
}

type GnsTsmV1 struct {
	client *Clientset
}

func newGnsTsmV1(client *Clientset) *GnsTsmV1 {
	return &GnsTsmV1{
		client: client,
	}
}

type ServicegroupTsmV1 struct {
	client *Clientset
}

func newServicegroupTsmV1(client *Clientset) *ServicegroupTsmV1 {
	return &ServicegroupTsmV1{
		client: client,
	}
}

type PolicypkgTsmV1 struct {
	client *Clientset
}

func newPolicypkgTsmV1(client *Clientset) *PolicypkgTsmV1 {
	return &PolicypkgTsmV1{
		client: client,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseroottsmtanzuvmwarecomv1.Root)
		return &RootRoot{
			client: group.client,
			Root:   result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &RootRoot{
			client: group.client,
			Root:   result,
		}, nil
	}
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootTsmV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.ConfigGvk != nil {
		err := group.client.
			Config().
			DeleteConfigByName(ctx, result.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		RootTsmV1().
		Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootTsmV1) CreateRootByName(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.ConfigGvk = nil

	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootTsmV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baseroottsmtanzuvmwarecomv1.Root) (*RootRoot, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			RootTsmV1().
			Roots().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootTsmV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootRoot, len(items))
		for k, v := range items {
			item, _ := v.(*baseroottsmtanzuvmwarecomv1.Root)
			result[k] = &RootRoot{
				client: group.client,
				Root:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootTsmV1().
			Roots().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootRoot, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootRoot{
				client: group.client,
				Root:   &item,
			}
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baseroottsmtanzuvmwarecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetRootRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetRootByName(ctx, hashedName)
}

func (c *Clientset) RootRoot() *rootRootTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &rootRootTsmV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baseroottsmtanzuvmwarecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *RootRoot) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	if obj.Spec.ConfigGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, obj.Spec.ConfigGvk.Name)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteConfig(ctx context.Context) (err error) {
	if obj.Spec.ConfigGvk != nil {
		err = obj.client.
			Config().DeleteConfigByName(ctx, obj.Spec.ConfigGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootTsmV1Chainer) Subscribe() {
	key := "roots.root.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerroottsmtanzuvmwarecomv1.NewRootInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *rootRootTsmV1Chainer) Unsubscribe() {
	key := "roots.root.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rootRootTsmV1Chainer) IsSubscribed() bool {
	key := "roots.root.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *rootRootTsmV1Chainer) Config(name string) *configConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.tsm.tanzu.vmware.com"] = name
	return &configConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootTsmV1Chainer) GetConfig(ctx context.Context, displayName string) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootTsmV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootTsmV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseconfigtsmtanzuvmwarecomv1.Config)
		return &ConfigConfig{
			client: group.client,
			Config: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &ConfigConfig{
			client: group.client,
			Config: result,
		}, nil
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	if result.Spec.GNSGvk != nil {
		err := group.client.
			Gns().
			DeleteGnsByName(ctx, result.Spec.GNSGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DNSGvk != nil {
		err := group.client.
			Gns().
			DeleteDnsByName(ctx, result.Spec.DNSGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.VMPPoliciesGvk != nil {
		err := group.client.
			Policypkg().
			DeleteVMpolicyByName(ctx, result.Spec.VMPPoliciesGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.DomainGvk != nil {
		err := group.client.
			Config().
			DeleteDomainByName(ctx, result.Spec.DomainGvk.Name)
		if err != nil {
			return err
		}
	}

	for _, v := range result.Spec.FooExampleGvk {
		err := group.client.
			Config().DeleteFooTypeABCByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.SvcGrpInfoGvk != nil {
		err := group.client.
			Servicegroup().
			DeleteSvcGroupLinkInfoByName(ctx, result.Spec.SvcGrpInfoGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/configGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GNSGvk = nil
	objToCreate.Spec.DNSGvk = nil
	objToCreate.Spec.VMPPoliciesGvk = nil
	objToCreate.Spec.DomainGvk = nil
	objToCreate.Spec.FooExampleGvk = nil
	objToCreate.Spec.SvcGrpInfoGvk = nil
	objToCreate.Spec.ACPPoliciesGvk = nil

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/configGvk",
		Value: baseconfigtsmtanzuvmwarecomv1.Child{
			Group: "config.tsm.tanzu.vmware.com",
			Kind:  "Config",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		RootTsmV1().
		Roots().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.Config) (*ConfigConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigTsmV1().
			Configs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueMyStr0 :=
		objToUpdate.Spec.MyStr0
	patchOpMyStr0 := PatchOp{
		Op:    "replace",
		Path:  "/spec/myStr0",
		Value: patchValueMyStr0,
	}
	patch = append(patch, patchOpMyStr0)

	if objToUpdate.Spec.MyStr1 != nil {
		patchValueMyStr1 :=
			objToUpdate.Spec.MyStr1
		patchOpMyStr1 := PatchOp{
			Op:    "replace",
			Path:  "/spec/myStr1",
			Value: patchValueMyStr1,
		}
		patch = append(patch, patchOpMyStr1)
	}

	if objToUpdate.Spec.MyStr2 != nil {
		patchValueMyStr2 :=
			objToUpdate.Spec.MyStr2
		patchOpMyStr2 := PatchOp{
			Op:    "replace",
			Path:  "/spec/myStr2",
			Value: patchValueMyStr2,
		}
		patch = append(patch, patchOpMyStr2)
	}

	patchValueXYZPort :=
		objToUpdate.Spec.XYZPort
	patchOpXYZPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/xYZPort",
		Value: patchValueXYZPort,
	}
	patch = append(patch, patchOpXYZPort)

	if objToUpdate.Spec.ABCHost != nil {
		patchValueABCHost :=
			objToUpdate.Spec.ABCHost
		patchOpABCHost := PatchOp{
			Op:    "replace",
			Path:  "/spec/aBCHost",
			Value: patchValueABCHost,
		}
		patch = append(patch, patchOpABCHost)
	}

	if objToUpdate.Spec.ClusterNamespaces != nil {
		patchValueClusterNamespaces :=
			objToUpdate.Spec.ClusterNamespaces
		patchOpClusterNamespaces := PatchOp{
			Op:    "replace",
			Path:  "/spec/clusterNamespaces",
			Value: patchValueClusterNamespaces,
		}
		patch = append(patch, patchOpClusterNamespaces)
	}

	patchValueTestValMarkers :=
		objToUpdate.Spec.TestValMarkers
	patchOpTestValMarkers := PatchOp{
		Op:    "replace",
		Path:  "/spec/testValMarkers",
		Value: patchValueTestValMarkers,
	}
	patch = append(patch, patchOpTestValMarkers)

	patchValueInstance :=
		objToUpdate.Spec.Instance
	patchOpInstance := PatchOp{
		Op:    "replace",
		Path:  "/spec/instance",
		Value: patchValueInstance,
	}
	patch = append(patch, patchOpInstance)

	patchValueCuOption :=
		objToUpdate.Spec.CuOption
	patchOpCuOption := PatchOp{
		Op:    "replace",
		Path:  "/spec/option_cu",
		Value: patchValueCuOption,
	}
	patch = append(patch, patchOpCuOption)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigtsmtanzuvmwarecomv1.Config)
			result[k] = &ConfigConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigTsmV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["roots.root.tsm.tanzu.vmware.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

// GetGNS returns child of given type
func (obj *ConfigConfig) GetGNS(ctx context.Context) (
	result *GnsGns, err error) {
	if obj.Spec.GNSGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "GNS")
	}
	return obj.client.Gns().GetGnsByName(ctx, obj.Spec.GNSGvk.Name)
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateGnsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteGNS(ctx context.Context) (err error) {
	if obj.Spec.GNSGvk != nil {
		err = obj.client.
			Gns().DeleteGnsByName(ctx, obj.Spec.GNSGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetDNS returns child of given type
func (obj *ConfigConfig) GetDNS(ctx context.Context) (
	result *GnsDns, err error) {
	if obj.Spec.DNSGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "DNS")
	}
	return obj.client.Gns().GetDnsByName(ctx, obj.Spec.DNSGvk.Name)
}

// AddDNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddDNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (result *GnsDns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateDnsByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteDNS(ctx context.Context) (err error) {
	if obj.Spec.DNSGvk != nil {
		err = obj.client.
			Gns().DeleteDnsByName(ctx, obj.Spec.DNSGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetVMPPolicies returns child of given type
func (obj *ConfigConfig) GetVMPPolicies(ctx context.Context) (
	result *PolicypkgVMpolicy, err error) {
	if obj.Spec.VMPPoliciesGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "VMPPolicies")
	}
	return obj.client.Policypkg().GetVMpolicyByName(ctx, obj.Spec.VMPPoliciesGvk.Name)
}

// AddVMPPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddVMPPolicies(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (result *PolicypkgVMpolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policypkg().CreateVMpolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteVMPPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteVMPPolicies(ctx context.Context) (err error) {
	if obj.Spec.VMPPoliciesGvk != nil {
		err = obj.client.
			Policypkg().DeleteVMpolicyByName(ctx, obj.Spec.VMPPoliciesGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetDomain returns child of given type
func (obj *ConfigConfig) GetDomain(ctx context.Context) (
	result *ConfigDomain, err error) {
	if obj.Spec.DomainGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "Domain")
	}
	return obj.client.Config().GetDomainByName(ctx, obj.Spec.DomainGvk.Name)
}

// AddDomain calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddDomain(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Domain) (result *ConfigDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateDomainByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteDomain calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteDomain(ctx context.Context) (err error) {
	if obj.Spec.DomainGvk != nil {
		err = obj.client.
			Config().DeleteDomainByName(ctx, obj.Spec.DomainGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllFooExample returns all children of given type
func (obj *ConfigConfig) GetAllFooExample(ctx context.Context) (
	result []*ConfigFooTypeABC, err error) {
	result = make([]*ConfigFooTypeABC, 0, len(obj.Spec.FooExampleGvk))
	for _, v := range obj.Spec.FooExampleGvk {
		l, err := obj.client.Config().GetFooTypeABCByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFooExample returns child which has given displayName
func (obj *ConfigConfig) GetFooExample(ctx context.Context,
	displayName string) (result *ConfigFooTypeABC, err error) {
	l, ok := obj.Spec.FooExampleGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "FooExample", displayName)
	}
	result, err = obj.client.Config().GetFooTypeABCByName(ctx, l.Name)
	return
}

// AddFooExample calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddFooExample(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (result *ConfigFooTypeABC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateFooTypeABCByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteFooExample calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteFooExample(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.FooExampleGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "FooExample", displayName)
	}
	err = obj.client.Config().DeleteFooTypeABCByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetSvcGrpInfo returns child of given type
func (obj *ConfigConfig) GetSvcGrpInfo(ctx context.Context) (
	result *ServicegroupSvcGroupLinkInfo, err error) {
	if obj.Spec.SvcGrpInfoGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "SvcGrpInfo")
	}
	return obj.client.Servicegroup().GetSvcGroupLinkInfoByName(ctx, obj.Spec.SvcGrpInfoGvk.Name)
}

// AddSvcGrpInfo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddSvcGrpInfo(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (result *ServicegroupSvcGroupLinkInfo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Servicegroup().CreateSvcGroupLinkInfoByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// DeleteSvcGrpInfo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteSvcGrpInfo(ctx context.Context) (err error) {
	if obj.Spec.SvcGrpInfoGvk != nil {
		err = obj.client.
			Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, obj.Spec.SvcGrpInfoGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

// GetAllACPPolicies returns all links of given type
func (obj *ConfigConfig) GetAllACPPolicies(ctx context.Context) (
	result []*PolicypkgAccessControlPolicy, err error) {
	result = make([]*PolicypkgAccessControlPolicy, 0, len(obj.Spec.ACPPoliciesGvk))
	for _, v := range obj.Spec.ACPPoliciesGvk {
		l, err := obj.client.Policypkg().GetAccessControlPolicyByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetACPPolicies returns link which has given displayName
func (obj *ConfigConfig) GetACPPolicies(ctx context.Context,
	displayName string) (result *PolicypkgAccessControlPolicy, err error) {
	l, ok := obj.Spec.ACPPoliciesGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Config.Config", "ACPPolicies", displayName)
	}
	result, err = obj.client.Policypkg().GetAccessControlPolicyByName(ctx, l.Name)
	return
}

// LinkACPPolicies links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *ConfigConfig) LinkACPPolicies(ctx context.Context,
	linkToAdd *PolicypkgAccessControlPolicy) error {

	payload := "{\"spec\": {\"aCPPoliciesGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"AccessControlPolicy\", \"group\": \"policypkg.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.ConfigTsmV1().Configs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Config = result
	return nil
}

// UnlinkACPPolicies unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *ConfigConfig) UnlinkACPPolicies(ctx context.Context,
	linkToRemove *PolicypkgAccessControlPolicy) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/aCPPoliciesGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.ConfigTsmV1().Configs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Config = result
	return nil

}

type configConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigTsmV1Chainer) Subscribe() {
	key := "configs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *configConfigTsmV1Chainer) Unsubscribe() {
	key := "configs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configConfigTsmV1Chainer) IsSubscribed() bool {
	key := "configs.config.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configConfigTsmV1Chainer) GNS(name string) *gnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["gnses.gns.tsm.tanzu.vmware.com"] = name
	return &gnsGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGNS calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetGNS(ctx context.Context, displayName string) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetGnsByName(ctx, hashedName)
}

// AddGNS calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddGNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (result *GnsGns, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateGnsByName(ctx, objToCreate)
}

// DeleteGNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteGNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteGnsByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) DNS() *dnsGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["dnses.gns.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &dnsGnsTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetDNS calculates hashed name of the object based on it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetDNS(ctx context.Context) (result *GnsDns, err error) {
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Gns().GetDnsByName(ctx, hashedName)
}

// AddDNS calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddDNS(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (result *GnsDns, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateDnsByName(ctx, objToCreate)
}

// DeleteDNS calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteDNS(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("dnses.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteDnsByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) VMPPolicies(name string) *vmpolicyPolicypkgTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["vmpolicies.policypkg.tsm.tanzu.vmware.com"] = name
	return &vmpolicyPolicypkgTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetVMPPolicies calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetVMPPolicies(ctx context.Context, displayName string) (result *PolicypkgVMpolicy, err error) {
	hashedName := helper.GetHashedName("vmpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policypkg().GetVMpolicyByName(ctx, hashedName)
}

// AddVMPPolicies calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddVMPPolicies(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (result *PolicypkgVMpolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("vmpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policypkg().CreateVMpolicyByName(ctx, objToCreate)
}

// DeleteVMPPolicies calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteVMPPolicies(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("vmpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policypkg().DeleteVMpolicyByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) Domain(name string) *domainConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["domains.config.tsm.tanzu.vmware.com"] = name
	return &domainConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetDomain calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetDomain(ctx context.Context, displayName string) (result *ConfigDomain, err error) {
	hashedName := helper.GetHashedName("domains.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetDomainByName(ctx, hashedName)
}

// AddDomain calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddDomain(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Domain) (result *ConfigDomain, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("domains.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateDomainByName(ctx, objToCreate)
}

// DeleteDomain calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteDomain(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("domains.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteDomainByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) FooExample(name string) *footypeabcConfigTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["footypeabcs.config.tsm.tanzu.vmware.com"] = name
	return &footypeabcConfigTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFooExample calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetFooExample(ctx context.Context, displayName string) (result *ConfigFooTypeABC, err error) {
	hashedName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Config().GetFooTypeABCByName(ctx, hashedName)
}

// AddFooExample calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddFooExample(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (result *ConfigFooTypeABC, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateFooTypeABCByName(ctx, objToCreate)
}

// DeleteFooExample calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteFooExample(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("footypeabcs.config.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Config().DeleteFooTypeABCByName(ctx, hashedName)
}

func (c *configConfigTsmV1Chainer) SvcGrpInfo(name string) *svcgrouplinkinfoServicegroupTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"] = name
	return &svcgrouplinkinfoServicegroupTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetSvcGrpInfo calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigTsmV1Chainer) GetSvcGrpInfo(ctx context.Context, displayName string) (result *ServicegroupSvcGroupLinkInfo, err error) {
	hashedName := helper.GetHashedName("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Servicegroup().GetSvcGroupLinkInfoByName(ctx, hashedName)
}

// AddSvcGrpInfo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigTsmV1Chainer) AddSvcGrpInfo(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (result *ServicegroupSvcGroupLinkInfo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Servicegroup().CreateSvcGroupLinkInfoByName(ctx, objToCreate)
}

// DeleteSvcGrpInfo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigTsmV1Chainer) DeleteSvcGrpInfo(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, hashedName)
}

// GetFooTypeABCByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetFooTypeABCByName(ctx context.Context, hashedName string) (*ConfigFooTypeABC, error) {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC)
		return &ConfigFooTypeABC{
			client:     group.client,
			FooTypeABC: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &ConfigFooTypeABC{
			client:     group.client,
			FooTypeABC: result,
		}, nil
	}
}

// DeleteFooTypeABCByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteFooTypeABCByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigTsmV1().
		FooTypeABCs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ConfigTsmV1().
		FooTypeABCs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooExampleGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateFooTypeABCByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateFooTypeABCByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (*ConfigFooTypeABC, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ConfigTsmV1().
		FooTypeABCs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"fooExampleGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"FooTypeABC\", \"group\": \"config.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigFooTypeABC{
		client:     group.client,
		FooTypeABC: result,
	}, nil
}

// UpdateFooTypeABCByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateFooTypeABCByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.FooTypeABC) (*ConfigFooTypeABC, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigTsmV1().
			FooTypeABCs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueFooA :=
		objToUpdate.Spec.FooA
	patchOpFooA := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooA",
		Value: patchValueFooA,
	}
	patch = append(patch, patchOpFooA)

	patchValueFooB :=
		objToUpdate.Spec.FooB
	patchOpFooB := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooB",
		Value: patchValueFooB,
	}
	patch = append(patch, patchOpFooB)

	patchValueFooC :=
		objToUpdate.Spec.FooC
	patchOpFooC := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooC",
		Value: patchValueFooC,
	}
	patch = append(patch, patchOpFooC)

	patchValueFooD :=
		objToUpdate.Spec.FooD
	patchOpFooD := PatchOp{
		Op:    "replace",
		Path:  "/spec/fooD",
		Value: patchValueFooD,
	}
	patch = append(patch, patchOpFooD)

	patchValueFooE :=
		objToUpdate.Spec.FooE
	patchOpFooE := PatchOp{
		Op:    "replace",
		Path:  "/spec/foo_e",
		Value: patchValueFooE,
	}
	patch = append(patch, patchOpFooE)

	patchValueFooF :=
		objToUpdate.Spec.FooF
	patchOpFooF := PatchOp{
		Op:    "replace",
		Path:  "/spec/foo_f",
		Value: patchValueFooF,
	}
	patch = append(patch, patchOpFooF)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigTsmV1().
		FooTypeABCs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigFooTypeABC{
		client:     group.client,
		FooTypeABC: result,
	}, nil
}

// ListFooTypeABCs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListFooTypeABCs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigFooTypeABC, err error) {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigFooTypeABC, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigtsmtanzuvmwarecomv1.FooTypeABC)
			result[k] = &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigTsmV1().
			FooTypeABCs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigFooTypeABC, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigFooTypeABC{
				client:     group.client,
				FooTypeABC: &item,
			}
		}
	}
	return
}

type ConfigFooTypeABC struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.FooTypeABC
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigFooTypeABC) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteFooTypeABCByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.FooTypeABC = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigFooTypeABC) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateFooTypeABCByName(ctx, obj.FooTypeABC)
	if err != nil {
		return err
	}
	obj.FooTypeABC = result.FooTypeABC
	return nil
}

func (obj *ConfigFooTypeABC) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type footypeabcConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *footypeabcConfigTsmV1Chainer) Subscribe() {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewFooTypeABCInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *footypeabcConfigTsmV1Chainer) Unsubscribe() {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *footypeabcConfigTsmV1Chainer) IsSubscribed() bool {
	key := "footypeabcs.config.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDomainByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) GetDomainByName(ctx context.Context, hashedName string) (*ConfigDomain, error) {
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseconfigtsmtanzuvmwarecomv1.Domain)
		return &ConfigDomain{
			client: group.client,
			Domain: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			ConfigTsmV1().
			Domains().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &ConfigDomain{
			client: group.client,
			Domain: result,
		}, nil
	}
}

// DeleteDomainByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigTsmV1) DeleteDomainByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Domains().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ConfigTsmV1().
		Domains().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/domainGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDomainByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigTsmV1) CreateDomainByName(ctx context.Context,
	objToCreate *baseconfigtsmtanzuvmwarecomv1.Domain) (*ConfigDomain, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ConfigTsmV1().
		Domains().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/domainGvk",
		Value: baseconfigtsmtanzuvmwarecomv1.Child{
			Group: "config.tsm.tanzu.vmware.com",
			Kind:  "Domain",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ConfigDomain{
		client: group.client,
		Domain: result,
	}, nil
}

// UpdateDomainByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigTsmV1) UpdateDomainByName(ctx context.Context,
	objToUpdate *baseconfigtsmtanzuvmwarecomv1.Domain) (*ConfigDomain, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ConfigTsmV1().
			Domains().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValuePointPort :=
		objToUpdate.Spec.PointPort
	patchOpPointPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/pointPort",
		Value: patchValuePointPort,
	}
	patch = append(patch, patchOpPointPort)

	patchValuePointString :=
		objToUpdate.Spec.PointString
	patchOpPointString := PatchOp{
		Op:    "replace",
		Path:  "/spec/pointString",
		Value: patchValuePointString,
	}
	patch = append(patch, patchOpPointString)

	patchValuePointInt :=
		objToUpdate.Spec.PointInt
	patchOpPointInt := PatchOp{
		Op:    "replace",
		Path:  "/spec/pointInt",
		Value: patchValuePointInt,
	}
	patch = append(patch, patchOpPointInt)

	if objToUpdate.Spec.PointMap != nil {
		patchValuePointMap :=
			objToUpdate.Spec.PointMap
		patchOpPointMap := PatchOp{
			Op:    "replace",
			Path:  "/spec/pointMap",
			Value: patchValuePointMap,
		}
		patch = append(patch, patchOpPointMap)
	}

	patchValuePointSlice :=
		objToUpdate.Spec.PointSlice
	patchOpPointSlice := PatchOp{
		Op:    "replace",
		Path:  "/spec/pointSlice",
		Value: patchValuePointSlice,
	}
	patch = append(patch, patchOpPointSlice)

	if objToUpdate.Spec.SliceOfPoints != nil {
		patchValueSliceOfPoints :=
			objToUpdate.Spec.SliceOfPoints
		patchOpSliceOfPoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/sliceOfPoints",
			Value: patchValueSliceOfPoints,
		}
		patch = append(patch, patchOpSliceOfPoints)
	}

	if objToUpdate.Spec.SliceOfArrPoints != nil {
		patchValueSliceOfArrPoints :=
			objToUpdate.Spec.SliceOfArrPoints
		patchOpSliceOfArrPoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/sliceOfArrPoints",
			Value: patchValueSliceOfArrPoints,
		}
		patch = append(patch, patchOpSliceOfArrPoints)
	}

	if objToUpdate.Spec.MapOfArrsPoints != nil {
		patchValueMapOfArrsPoints :=
			objToUpdate.Spec.MapOfArrsPoints
		patchOpMapOfArrsPoints := PatchOp{
			Op:    "replace",
			Path:  "/spec/mapOfArrsPoints",
			Value: patchValueMapOfArrsPoints,
		}
		patch = append(patch, patchOpMapOfArrsPoints)
	}

	patchValuePointStruct :=
		objToUpdate.Spec.PointStruct
	patchOpPointStruct := PatchOp{
		Op:    "replace",
		Path:  "/spec/pointStruct",
		Value: patchValuePointStruct,
	}
	patch = append(patch, patchOpPointStruct)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ConfigTsmV1().
		Domains().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ConfigDomain{
		client: group.client,
		Domain: result,
	}, nil
}

// ListDomains returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigTsmV1) ListDomains(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigDomain, err error) {
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigDomain, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigtsmtanzuvmwarecomv1.Domain)
			result[k] = &ConfigDomain{
				client: group.client,
				Domain: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigTsmV1().
			Domains().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigDomain, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigDomain{
				client: group.client,
				Domain: &item,
			}
		}
	}
	return
}

type ConfigDomain struct {
	client *Clientset
	*baseconfigtsmtanzuvmwarecomv1.Domain
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigDomain) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteDomainByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Domain = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigDomain) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateDomainByName(ctx, obj.Domain)
	if err != nil {
		return err
	}
	obj.Domain = result.Domain
	return nil
}

func (obj *ConfigDomain) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type domainConfigTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *domainConfigTsmV1Chainer) Subscribe() {
	key := "domains.config.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigtsmtanzuvmwarecomv1.NewDomainInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *domainConfigTsmV1Chainer) Unsubscribe() {
	key := "domains.config.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *domainConfigTsmV1Chainer) IsSubscribed() bool {
	key := "domains.config.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetRandomGnsDataByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetRandomGnsDataByName(ctx context.Context, hashedName string) (*GnsRandomGnsData, error) {
	key := "randomgnsdatas.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.RandomGnsData)
		return &GnsRandomGnsData{
			client:        group.client,
			RandomGnsData: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			RandomGnsDatas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsRandomGnsData{
			client:        group.client,
			RandomGnsData: result,
		}, nil
	}
}

// DeleteRandomGnsDataByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteRandomGnsDataByName(ctx context.Context, hashedName string) (err error) {

	err = group.client.baseClient.
		GnsTsmV1().
		RandomGnsDatas().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRandomGnsDataByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateRandomGnsDataByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.RandomGnsData) (*GnsRandomGnsData, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		RandomGnsDatas().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsRandomGnsData{
		client:        group.client,
		RandomGnsData: result,
	}, nil
}

// SetRandomGnsDataStatusByName sets user defined status
func (group *GnsTsmV1) SetRandomGnsDataStatusByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.RandomGnsData, status *basegnstsmtanzuvmwarecomv1.RandomStatus) (*GnsRandomGnsData, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		GnsTsmV1().
		RandomGnsDatas().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/status",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		GnsTsmV1().
		RandomGnsDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &GnsRandomGnsData{
		client:        group.client,
		RandomGnsData: result,
	}, nil
}

// UpdateRandomGnsDataByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateRandomGnsDataByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.RandomGnsData) (*GnsRandomGnsData, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			RandomGnsDatas().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		RandomGnsDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsRandomGnsData{
		client:        group.client,
		RandomGnsData: result,
	}, nil
}

// ListRandomGnsDatas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListRandomGnsDatas(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsRandomGnsData, err error) {
	key := "randomgnsdatas.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsRandomGnsData, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.RandomGnsData)
			result[k] = &GnsRandomGnsData{
				client:        group.client,
				RandomGnsData: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			RandomGnsDatas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsRandomGnsData, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsRandomGnsData{
				client:        group.client,
				RandomGnsData: &item,
			}
		}
	}
	return
}

type GnsRandomGnsData struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.RandomGnsData
}

// Delete removes obj and all it's children from the database.
func (obj *GnsRandomGnsData) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteRandomGnsDataByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RandomGnsData = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsRandomGnsData) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateRandomGnsDataByName(ctx, obj.RandomGnsData)
	if err != nil {
		return err
	}
	obj.RandomGnsData = result.RandomGnsData
	return nil
}

// SetStatus sets user defined status
func (obj *GnsRandomGnsData) SetStatus(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.RandomStatus) error {
	result, err := obj.client.Gns().SetRandomGnsDataStatusByName(ctx, obj.RandomGnsData, status)
	if err != nil {
		return err
	}
	obj.RandomGnsData = result.RandomGnsData
	return nil
}

// GetStatus to get user defined status
func (obj *GnsRandomGnsData) GetStatus(ctx context.Context) (*basegnstsmtanzuvmwarecomv1.RandomStatus, error) {
	getObj, err := obj.client.Gns().GetRandomGnsDataByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *GnsRandomGnsData) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Gns().SetRandomGnsDataStatusByName(ctx, obj.RandomGnsData, &basegnstsmtanzuvmwarecomv1.RandomStatus{})
	if err != nil {
		return err
	}
	obj.RandomGnsData = result.RandomGnsData
	return nil
}

// GetGnsRandomGnsData calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetGnsRandomGnsData(ctx context.Context, displayName string) (result *GnsRandomGnsData, err error) {
	hashedName := helper.GetHashedName("randomgnsdatas.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().GetRandomGnsDataByName(ctx, hashedName)
}

func (c *Clientset) GnsRandomGnsData(displayName string) *randomgnsdataGnsTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["randomgnsdatas.gns.tsm.tanzu.vmware.com"] = displayName
	return &randomgnsdataGnsTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// AddGnsRandomGnsData calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddGnsRandomGnsData(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.RandomGnsData) (result *GnsRandomGnsData, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Gns().CreateRandomGnsDataByName(ctx, objToCreate)
}

// DeleteGnsRandomGnsData calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteGnsRandomGnsData(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("randomgnsdatas.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().DeleteRandomGnsDataByName(ctx, hashedName)
}

type randomgnsdataGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *randomgnsdataGnsTsmV1Chainer) Subscribe() {
	key := "randomgnsdatas.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewRandomGnsDataInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *randomgnsdataGnsTsmV1Chainer) Unsubscribe() {
	key := "randomgnsdatas.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *randomgnsdataGnsTsmV1Chainer) IsSubscribed() bool {
	key := "randomgnsdatas.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// ClearStatus to clear user defined status
func (c *randomgnsdataGnsTsmV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("randomgnsdatas.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetRandomGnsDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetRandomGnsDataStatusByName(ctx, obj.RandomGnsData, nil)
	return err
}

// GetStatus to get user defined status
func (c *randomgnsdataGnsTsmV1Chainer) GetStatus(ctx context.Context) (result *basegnstsmtanzuvmwarecomv1.RandomStatus, err error) {
	hashedName := helper.GetHashedName("randomgnsdatas.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetRandomGnsDataByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *randomgnsdataGnsTsmV1Chainer) SetStatus(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.RandomStatus) (err error) {
	hashedName := helper.GetHashedName("randomgnsdatas.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetRandomGnsDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetRandomGnsDataStatusByName(ctx, obj.RandomGnsData, status)
	return err
}

// GetFooByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetFooByName(ctx context.Context, hashedName string) (*GnsFoo, error) {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.Foo)
		return &GnsFoo{
			client: group.client,
			Foo:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Foos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsFoo{
			client: group.client,
			Foo:    result,
		}, nil
	}
}

// DeleteFooByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteFooByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		Foos().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		Foos().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateFooByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateFooByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Foo) (*GnsFoo, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		Foos().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/fooGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Foo",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsFoo{
		client: group.client,
		Foo:    result,
	}, nil
}

// UpdateFooByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateFooByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Foo) (*GnsFoo, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			Foos().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValuePassword :=
		objToUpdate.Spec.Password
	patchOpPassword := PatchOp{
		Op:    "replace",
		Path:  "/spec/password",
		Value: patchValuePassword,
	}
	patch = append(patch, patchOpPassword)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		Foos().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsFoo{
		client: group.client,
		Foo:    result,
	}, nil
}

// ListFoos returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListFoos(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsFoo, err error) {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsFoo, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.Foo)
			result[k] = &GnsFoo{
				client: group.client,
				Foo:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			Foos().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsFoo, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsFoo{
				client: group.client,
				Foo:    &item,
			}
		}
	}
	return
}

type GnsFoo struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Foo
}

// Delete removes obj and all it's children from the database.
func (obj *GnsFoo) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteFooByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Foo = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsFoo) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateFooByName(ctx, obj.Foo)
	if err != nil {
		return err
	}
	obj.Foo = result.Foo
	return nil
}

func (obj *GnsFoo) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type fooGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *fooGnsTsmV1Chainer) Subscribe() {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewFooInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *fooGnsTsmV1Chainer) Unsubscribe() {
	key := "foos.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *fooGnsTsmV1Chainer) IsSubscribed() bool {
	key := "foos.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetGnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetGnsByName(ctx context.Context, hashedName string) (*GnsGns, error) {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.Gns)
		return &GnsGns{
			client: group.client,
			Gns:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsGns{
			client: group.client,
			Gns:    result,
		}, nil
	}
}

// DeleteGnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteGnsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.GnsServiceGroupsGvk {
		err := group.client.
			Servicegroup().DeleteSvcGroupByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.GnsAccessControlPolicyGvk != nil {
		err := group.client.
			Policypkg().
			DeleteAccessControlPolicyByName(ctx, result.Spec.GnsAccessControlPolicyGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.FooChildGvk != nil {
		err := group.client.
			Gns().
			DeleteBarChildByName(ctx, result.Spec.FooChildGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.IgnoreChildGvk != nil {
		err := group.client.
			Gns().
			DeleteIgnoreChildByName(ctx, result.Spec.IgnoreChildGvk.Name)
		if err != nil {
			return err
		}
	}

	if result.Spec.FooGvk != nil {
		err := group.client.
			Gns().
			DeleteFooByName(ctx, result.Spec.FooGvk.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gNSGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateGnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateGnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.GnsServiceGroupsGvk = nil
	objToCreate.Spec.GnsAccessControlPolicyGvk = nil
	objToCreate.Spec.FooChildGvk = nil
	objToCreate.Spec.IgnoreChildGvk = nil
	objToCreate.Spec.FooGvk = nil
	objToCreate.Spec.DnsGvk = nil

	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/gNSGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Gns",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// SetGnsStateByName sets user defined status
func (group *GnsTsmV1) SetGnsStateByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Gns, status *basegnstsmtanzuvmwarecomv1.GnsState) (*GnsGns, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/state",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// UpdateGnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateGnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Gns) (*GnsGns, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			Gnses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDomain :=
		objToUpdate.Spec.Domain
	patchOpDomain := PatchOp{
		Op:    "replace",
		Path:  "/spec/domain",
		Value: patchValueDomain,
	}
	patch = append(patch, patchOpDomain)

	patchValueUseSharedGateway :=
		objToUpdate.Spec.UseSharedGateway
	patchOpUseSharedGateway := PatchOp{
		Op:    "replace",
		Path:  "/spec/useSharedGateway",
		Value: patchValueUseSharedGateway,
	}
	patch = append(patch, patchOpUseSharedGateway)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueMeta :=
		objToUpdate.Spec.Meta
	patchOpMeta := PatchOp{
		Op:    "replace",
		Path:  "/spec/meta",
		Value: patchValueMeta,
	}
	patch = append(patch, patchOpMeta)

	patchValuePort :=
		objToUpdate.Spec.Port
	patchOpPort := PatchOp{
		Op:    "replace",
		Path:  "/spec/port",
		Value: patchValuePort,
	}
	patch = append(patch, patchOpPort)

	patchValueOtherDescription :=
		objToUpdate.Spec.OtherDescription
	patchOpOtherDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/otherDescription",
		Value: patchValueOtherDescription,
	}
	patch = append(patch, patchOpOtherDescription)

	if objToUpdate.Spec.MapPointer != nil {
		patchValueMapPointer :=
			objToUpdate.Spec.MapPointer
		patchOpMapPointer := PatchOp{
			Op:    "replace",
			Path:  "/spec/mapPointer",
			Value: patchValueMapPointer,
		}
		patch = append(patch, patchOpMapPointer)
	}

	patchValueSlicePointer :=
		objToUpdate.Spec.SlicePointer
	patchOpSlicePointer := PatchOp{
		Op:    "replace",
		Path:  "/spec/slicePointer",
		Value: patchValueSlicePointer,
	}
	patch = append(patch, patchOpSlicePointer)

	patchValueWorkloadSpec :=
		objToUpdate.Spec.WorkloadSpec
	patchOpWorkloadSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/workloadSpec",
		Value: patchValueWorkloadSpec,
	}
	patch = append(patch, patchOpWorkloadSpec)

	patchValueDifferentSpec :=
		objToUpdate.Spec.DifferentSpec
	patchOpDifferentSpec := PatchOp{
		Op:    "replace",
		Path:  "/spec/differentSpec",
		Value: patchValueDifferentSpec,
	}
	patch = append(patch, patchOpDifferentSpec)

	patchValueServiceSegmentRef :=
		objToUpdate.Spec.ServiceSegmentRef
	patchOpServiceSegmentRef := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceSegmentRef",
		Value: patchValueServiceSegmentRef,
	}
	patch = append(patch, patchOpServiceSegmentRef)

	patchValueServiceSegmentRefPointer :=
		objToUpdate.Spec.ServiceSegmentRefPointer
	patchOpServiceSegmentRefPointer := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceSegmentRefPointer",
		Value: patchValueServiceSegmentRefPointer,
	}
	patch = append(patch, patchOpServiceSegmentRefPointer)

	if objToUpdate.Spec.ServiceSegmentRefs != nil {
		patchValueServiceSegmentRefs :=
			objToUpdate.Spec.ServiceSegmentRefs
		patchOpServiceSegmentRefs := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceSegmentRefs",
			Value: patchValueServiceSegmentRefs,
		}
		patch = append(patch, patchOpServiceSegmentRefs)
	}

	if objToUpdate.Spec.ServiceSegmentRefMap != nil {
		patchValueServiceSegmentRefMap :=
			objToUpdate.Spec.ServiceSegmentRefMap
		patchOpServiceSegmentRefMap := PatchOp{
			Op:    "replace",
			Path:  "/spec/serviceSegmentRefMap",
			Value: patchValueServiceSegmentRefMap,
		}
		patch = append(patch, patchOpServiceSegmentRefMap)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsGns{
		client: group.client,
		Gns:    result,
	}, nil
}

// ListGnses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListGnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsGns, err error) {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsGns, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.Gns)
			result[k] = &GnsGns{
				client: group.client,
				Gns:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			Gnses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsGns, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsGns{
				client: group.client,
				Gns:    &item,
			}
		}
	}
	return
}

type GnsGns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Gns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsGns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteGnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Gns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsGns) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateGnsByName(ctx, obj.Gns)
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

// SetState sets user defined status
func (obj *GnsGns) SetState(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.GnsState) error {
	result, err := obj.client.Gns().SetGnsStateByName(ctx, obj.Gns, status)
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

// GetState to get user defined status
func (obj *GnsGns) GetState(ctx context.Context) (*basegnstsmtanzuvmwarecomv1.GnsState, error) {
	getObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.State, nil
}

// ClearState to clear user defined status
func (obj *GnsGns) ClearState(ctx context.Context) error {
	result, err := obj.client.Gns().SetGnsStateByName(ctx, obj.Gns, &basegnstsmtanzuvmwarecomv1.GnsState{})
	if err != nil {
		return err
	}
	obj.Gns = result.Gns
	return nil
}

func (obj *GnsGns) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

// GetAllGnsServiceGroups returns all children of given type
func (obj *GnsGns) GetAllGnsServiceGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.GnsServiceGroupsGvk))
	for _, v := range obj.Spec.GnsServiceGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetGnsServiceGroups returns child which has given displayName
func (obj *GnsGns) GetGnsServiceGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.GnsServiceGroupsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "GnsServiceGroups", displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (result *ServicegroupSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Servicegroup().CreateSvcGroupByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteGnsServiceGroups(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.GnsServiceGroupsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Gns.Gns", "GnsServiceGroups", displayName)
	}
	err = obj.client.Servicegroup().DeleteSvcGroupByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetGnsAccessControlPolicy returns child of given type
func (obj *GnsGns) GetGnsAccessControlPolicy(ctx context.Context) (
	result *PolicypkgAccessControlPolicy, err error) {
	if obj.Spec.GnsAccessControlPolicyGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "GnsAccessControlPolicy")
	}
	return obj.client.Policypkg().GetAccessControlPolicyByName(ctx, obj.Spec.GnsAccessControlPolicyGvk.Name)
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (result *PolicypkgAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policypkg().CreateAccessControlPolicyByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteGnsAccessControlPolicy(ctx context.Context) (err error) {
	if obj.Spec.GnsAccessControlPolicyGvk != nil {
		err = obj.client.
			Policypkg().DeleteAccessControlPolicyByName(ctx, obj.Spec.GnsAccessControlPolicyGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetFooChild returns child of given type
func (obj *GnsGns) GetFooChild(ctx context.Context) (
	result *GnsBarChild, err error) {
	if obj.Spec.FooChildGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "FooChild")
	}
	return obj.client.Gns().GetBarChildByName(ctx, obj.Spec.FooChildGvk.Name)
}

// AddFooChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddFooChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (result *GnsBarChild, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateBarChildByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteFooChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteFooChild(ctx context.Context) (err error) {
	if obj.Spec.FooChildGvk != nil {
		err = obj.client.
			Gns().DeleteBarChildByName(ctx, obj.Spec.FooChildGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetIgnoreChild returns child of given type
func (obj *GnsGns) GetIgnoreChild(ctx context.Context) (
	result *GnsIgnoreChild, err error) {
	if obj.Spec.IgnoreChildGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "IgnoreChild")
	}
	return obj.client.Gns().GetIgnoreChildByName(ctx, obj.Spec.IgnoreChildGvk.Name)
}

// AddIgnoreChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddIgnoreChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (result *GnsIgnoreChild, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateIgnoreChildByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteIgnoreChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteIgnoreChild(ctx context.Context) (err error) {
	if obj.Spec.IgnoreChildGvk != nil {
		err = obj.client.
			Gns().DeleteIgnoreChildByName(ctx, obj.Spec.IgnoreChildGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetFoo returns child of given type
func (obj *GnsGns) GetFoo(ctx context.Context) (
	result *GnsFoo, err error) {
	if obj.Spec.FooGvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "Gns.Gns", "Foo")
	}
	return obj.client.Gns().GetFooByName(ctx, obj.Spec.FooGvk.Name)
}

// AddFoo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *GnsGns) AddFoo(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Foo) (result *GnsFoo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["gnses.gns.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["gnses.gns.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Gns().CreateFooByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Gns().GetGnsByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// DeleteFoo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *GnsGns) DeleteFoo(ctx context.Context) (err error) {
	if obj.Spec.FooGvk != nil {
		err = obj.client.
			Gns().DeleteFooByName(ctx, obj.Spec.FooGvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
		Gns().GetGnsByName(ctx, obj.GetName())
	if err == nil {
		obj.Gns = updatedObj.Gns
	}
	return
}

// GetDns returns link of given type
func (obj *GnsGns) GetDns(ctx context.Context) (
	result *GnsDns, err error) {
	if obj.Spec.DnsGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Gns.Gns", "Dns")
	}
	return obj.client.Gns().GetDnsByName(ctx, obj.Spec.DnsGvk.Name)
}

// LinkDns links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *GnsGns) LinkDns(ctx context.Context,
	linkToAdd *GnsDns) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dnsGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Dns",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Gns = result
	return nil
}

// UnlinkDns unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *GnsGns) UnlinkDns(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dnsGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.GnsTsmV1().Gnses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Gns = result
	return nil

}

type gnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *gnsGnsTsmV1Chainer) Subscribe() {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewGnsInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *gnsGnsTsmV1Chainer) Unsubscribe() {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *gnsGnsTsmV1Chainer) IsSubscribed() bool {
	key := "gnses.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// ClearState to clear user defined status
func (c *gnsGnsTsmV1Chainer) ClearState(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetGnsByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetGnsStateByName(ctx, obj.Gns, nil)
	return err
}

// GetState to get user defined status
func (c *gnsGnsTsmV1Chainer) GetState(ctx context.Context) (result *basegnstsmtanzuvmwarecomv1.GnsState, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetGnsByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.State, nil
}

// SetState sets user defined status
func (c *gnsGnsTsmV1Chainer) SetState(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.GnsState) (err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetGnsByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetGnsStateByName(ctx, obj.Gns, status)
	return err
}

func (c *gnsGnsTsmV1Chainer) GnsServiceGroups(name string) *svcgroupServicegroupTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["svcgroups.servicegroup.tsm.tanzu.vmware.com"] = name
	return &svcgroupServicegroupTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsServiceGroups calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetGnsServiceGroups(ctx context.Context, displayName string) (result *ServicegroupSvcGroup, err error) {
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Servicegroup().GetSvcGroupByName(ctx, hashedName)
}

// AddGnsServiceGroups calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddGnsServiceGroups(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (result *ServicegroupSvcGroup, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Servicegroup().CreateSvcGroupByName(ctx, objToCreate)
}

// DeleteGnsServiceGroups calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteGnsServiceGroups(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("svcgroups.servicegroup.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Servicegroup().DeleteSvcGroupByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) GnsAccessControlPolicy(name string) *accesscontrolpolicyPolicypkgTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] = name
	return &accesscontrolpolicyPolicypkgTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetGnsAccessControlPolicy calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetGnsAccessControlPolicy(ctx context.Context, displayName string) (result *PolicypkgAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policypkg().GetAccessControlPolicyByName(ctx, hashedName)
}

// AddGnsAccessControlPolicy calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddGnsAccessControlPolicy(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (result *PolicypkgAccessControlPolicy, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policypkg().CreateAccessControlPolicyByName(ctx, objToCreate)
}

// DeleteGnsAccessControlPolicy calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteGnsAccessControlPolicy(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policypkg().DeleteAccessControlPolicyByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) FooChild() *barchildGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["barchilds.gns.tsm.tanzu.vmware.com"] = helper.DEFAULT_KEY
	return &barchildGnsTsmV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetFooChild calculates hashed name of the object based on it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetFooChild(ctx context.Context) (result *GnsBarChild, err error) {
	hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Gns().GetBarChildByName(ctx, hashedName)
}

// AddFooChild calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddFooChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (result *GnsBarChild, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateBarChildByName(ctx, objToCreate)
}

// DeleteFooChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteFooChild(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("barchilds.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteBarChildByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) IgnoreChild(name string) *ignorechildGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["ignorechilds.gns.tsm.tanzu.vmware.com"] = name
	return &ignorechildGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetIgnoreChild calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetIgnoreChild(ctx context.Context, displayName string) (result *GnsIgnoreChild, err error) {
	hashedName := helper.GetHashedName("ignorechilds.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetIgnoreChildByName(ctx, hashedName)
}

// AddIgnoreChild calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddIgnoreChild(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (result *GnsIgnoreChild, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("ignorechilds.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateIgnoreChildByName(ctx, objToCreate)
}

// DeleteIgnoreChild calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteIgnoreChild(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("ignorechilds.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteIgnoreChildByName(ctx, hashedName)
}

func (c *gnsGnsTsmV1Chainer) Foo(name string) *fooGnsTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["foos.gns.tsm.tanzu.vmware.com"] = name
	return &fooGnsTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFoo calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *gnsGnsTsmV1Chainer) GetFoo(ctx context.Context, displayName string) (result *GnsFoo, err error) {
	hashedName := helper.GetHashedName("foos.gns.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Gns().GetFooByName(ctx, hashedName)
}

// AddFoo calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *gnsGnsTsmV1Chainer) AddFoo(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Foo) (result *GnsFoo, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("foos.gns.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Gns().CreateFooByName(ctx, objToCreate)
}

// DeleteFoo calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *gnsGnsTsmV1Chainer) DeleteFoo(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("foos.gns.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Gns().DeleteFooByName(ctx, hashedName)
}

// GetBarChildByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetBarChildByName(ctx context.Context, hashedName string) (*GnsBarChild, error) {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.BarChild)
		return &GnsBarChild{
			client:   group.client,
			BarChild: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsBarChild{
			client:   group.client,
			BarChild: result,
		}, nil
	}
}

// DeleteBarChildByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteBarChildByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		BarChilds().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/fooChildGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateBarChildByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateBarChildByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.BarChild) (*GnsBarChild, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/fooChildGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "BarChild",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// UpdateBarChildByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateBarChildByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.BarChild) (*GnsBarChild, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			BarChilds().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		BarChilds().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsBarChild{
		client:   group.client,
		BarChild: result,
	}, nil
}

// ListBarChilds returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListBarChilds(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsBarChild, err error) {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsBarChild, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.BarChild)
			result[k] = &GnsBarChild{
				client:   group.client,
				BarChild: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			BarChilds().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsBarChild, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsBarChild{
				client:   group.client,
				BarChild: &item,
			}
		}
	}
	return
}

type GnsBarChild struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.BarChild
}

// Delete removes obj and all it's children from the database.
func (obj *GnsBarChild) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteBarChildByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.BarChild = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsBarChild) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateBarChildByName(ctx, obj.BarChild)
	if err != nil {
		return err
	}
	obj.BarChild = result.BarChild
	return nil
}

func (obj *GnsBarChild) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type barchildGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *barchildGnsTsmV1Chainer) Subscribe() {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewBarChildInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *barchildGnsTsmV1Chainer) Unsubscribe() {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *barchildGnsTsmV1Chainer) IsSubscribed() bool {
	key := "barchilds.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetIgnoreChildByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetIgnoreChildByName(ctx context.Context, hashedName string) (*GnsIgnoreChild, error) {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.IgnoreChild)
		return &GnsIgnoreChild{
			client:      group.client,
			IgnoreChild: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsIgnoreChild{
			client:      group.client,
			IgnoreChild: result,
		}, nil
	}
}

// DeleteIgnoreChildByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteIgnoreChildByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		IgnoreChilds().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		IgnoreChilds().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/ignoreChildGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateIgnoreChildByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateIgnoreChildByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (*GnsIgnoreChild, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		IgnoreChilds().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/ignoreChildGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "IgnoreChild",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsIgnoreChild{
		client:      group.client,
		IgnoreChild: result,
	}, nil
}

// UpdateIgnoreChildByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateIgnoreChildByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.IgnoreChild) (*GnsIgnoreChild, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			IgnoreChilds().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueName :=
		objToUpdate.Spec.Name
	patchOpName := PatchOp{
		Op:    "replace",
		Path:  "/spec/name",
		Value: patchValueName,
	}
	patch = append(patch, patchOpName)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		IgnoreChilds().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsIgnoreChild{
		client:      group.client,
		IgnoreChild: result,
	}, nil
}

// ListIgnoreChilds returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListIgnoreChilds(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsIgnoreChild, err error) {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsIgnoreChild, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.IgnoreChild)
			result[k] = &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			IgnoreChilds().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsIgnoreChild, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsIgnoreChild{
				client:      group.client,
				IgnoreChild: &item,
			}
		}
	}
	return
}

type GnsIgnoreChild struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.IgnoreChild
}

// Delete removes obj and all it's children from the database.
func (obj *GnsIgnoreChild) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteIgnoreChildByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.IgnoreChild = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsIgnoreChild) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateIgnoreChildByName(ctx, obj.IgnoreChild)
	if err != nil {
		return err
	}
	obj.IgnoreChild = result.IgnoreChild
	return nil
}

func (obj *GnsIgnoreChild) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type ignorechildGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *ignorechildGnsTsmV1Chainer) Subscribe() {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewIgnoreChildInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *ignorechildGnsTsmV1Chainer) Unsubscribe() {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *ignorechildGnsTsmV1Chainer) IsSubscribed() bool {
	key := "ignorechilds.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetDnsByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetDnsByName(ctx context.Context, hashedName string) (*GnsDns, error) {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.Dns)
		return &GnsDns{
			client: group.client,
			Dns:    result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			Dnses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsDns{
			client: group.client,
			Dns:    result,
		}, nil
	}
}

// DeleteDnsByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteDnsByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		GnsTsmV1().
		Dnses().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/dNSGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateDnsByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateDnsByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.Dns) (*GnsDns, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/dNSGvk",
		Value: basegnstsmtanzuvmwarecomv1.Child{
			Group: "gns.tsm.tanzu.vmware.com",
			Kind:  "Dns",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// UpdateDnsByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateDnsByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.Dns) (*GnsDns, error) {
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			Dnses().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		Dnses().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsDns{
		client: group.client,
		Dns:    result,
	}, nil
}

// ListDnses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListDnses(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsDns, err error) {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsDns, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.Dns)
			result[k] = &GnsDns{
				client: group.client,
				Dns:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			Dnses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsDns, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsDns{
				client: group.client,
				Dns:    &item,
			}
		}
	}
	return
}

type GnsDns struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.Dns
}

// Delete removes obj and all it's children from the database.
func (obj *GnsDns) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteDnsByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Dns = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsDns) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateDnsByName(ctx, obj.Dns)
	if err != nil {
		return err
	}
	obj.Dns = result.Dns
	return nil
}

func (obj *GnsDns) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type dnsGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *dnsGnsTsmV1Chainer) Subscribe() {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewDnsInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *dnsGnsTsmV1Chainer) Unsubscribe() {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *dnsGnsTsmV1Chainer) IsSubscribed() bool {
	key := "dnses.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAdditionalGnsDataByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) GetAdditionalGnsDataByName(ctx context.Context, hashedName string) (*GnsAdditionalGnsData, error) {
	key := "additionalgnsdatas.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basegnstsmtanzuvmwarecomv1.AdditionalGnsData)
		return &GnsAdditionalGnsData{
			client:            group.client,
			AdditionalGnsData: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			GnsTsmV1().
			AdditionalGnsDatas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &GnsAdditionalGnsData{
			client:            group.client,
			AdditionalGnsData: result,
		}, nil
	}
}

// DeleteAdditionalGnsDataByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *GnsTsmV1) DeleteAdditionalGnsDataByName(ctx context.Context, hashedName string) (err error) {

	err = group.client.baseClient.
		GnsTsmV1().
		AdditionalGnsDatas().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAdditionalGnsDataByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *GnsTsmV1) CreateAdditionalGnsDataByName(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.AdditionalGnsData) (*GnsAdditionalGnsData, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		GnsTsmV1().
		AdditionalGnsDatas().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &GnsAdditionalGnsData{
		client:            group.client,
		AdditionalGnsData: result,
	}, nil
}

// SetAdditionalGnsDataStatusByName sets user defined status
func (group *GnsTsmV1) SetAdditionalGnsDataStatusByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.AdditionalGnsData, status *basegnstsmtanzuvmwarecomv1.AdditionalStatus) (*GnsAdditionalGnsData, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		GnsTsmV1().
		AdditionalGnsDatas().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/status",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		GnsTsmV1().
		AdditionalGnsDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &GnsAdditionalGnsData{
		client:            group.client,
		AdditionalGnsData: result,
	}, nil
}

// UpdateAdditionalGnsDataByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *GnsTsmV1) UpdateAdditionalGnsDataByName(ctx context.Context,
	objToUpdate *basegnstsmtanzuvmwarecomv1.AdditionalGnsData) (*GnsAdditionalGnsData, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			GnsTsmV1().
			AdditionalGnsDatas().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		GnsTsmV1().
		AdditionalGnsDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &GnsAdditionalGnsData{
		client:            group.client,
		AdditionalGnsData: result,
	}, nil
}

// ListAdditionalGnsDatas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *GnsTsmV1) ListAdditionalGnsDatas(ctx context.Context,
	opts metav1.ListOptions) (result []*GnsAdditionalGnsData, err error) {
	key := "additionalgnsdatas.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*GnsAdditionalGnsData, len(items))
		for k, v := range items {
			item, _ := v.(*basegnstsmtanzuvmwarecomv1.AdditionalGnsData)
			result[k] = &GnsAdditionalGnsData{
				client:            group.client,
				AdditionalGnsData: item,
			}
		}
	} else {
		list, err := group.client.baseClient.GnsTsmV1().
			AdditionalGnsDatas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*GnsAdditionalGnsData, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &GnsAdditionalGnsData{
				client:            group.client,
				AdditionalGnsData: &item,
			}
		}
	}
	return
}

type GnsAdditionalGnsData struct {
	client *Clientset
	*basegnstsmtanzuvmwarecomv1.AdditionalGnsData
}

// Delete removes obj and all it's children from the database.
func (obj *GnsAdditionalGnsData) Delete(ctx context.Context) error {
	err := obj.client.Gns().DeleteAdditionalGnsDataByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AdditionalGnsData = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *GnsAdditionalGnsData) Update(ctx context.Context) error {
	result, err := obj.client.Gns().UpdateAdditionalGnsDataByName(ctx, obj.AdditionalGnsData)
	if err != nil {
		return err
	}
	obj.AdditionalGnsData = result.AdditionalGnsData
	return nil
}

// SetStatus sets user defined status
func (obj *GnsAdditionalGnsData) SetStatus(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.AdditionalStatus) error {
	result, err := obj.client.Gns().SetAdditionalGnsDataStatusByName(ctx, obj.AdditionalGnsData, status)
	if err != nil {
		return err
	}
	obj.AdditionalGnsData = result.AdditionalGnsData
	return nil
}

// GetStatus to get user defined status
func (obj *GnsAdditionalGnsData) GetStatus(ctx context.Context) (*basegnstsmtanzuvmwarecomv1.AdditionalStatus, error) {
	getObj, err := obj.client.Gns().GetAdditionalGnsDataByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *GnsAdditionalGnsData) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Gns().SetAdditionalGnsDataStatusByName(ctx, obj.AdditionalGnsData, &basegnstsmtanzuvmwarecomv1.AdditionalStatus{})
	if err != nil {
		return err
	}
	obj.AdditionalGnsData = result.AdditionalGnsData
	return nil
}

// GetGnsAdditionalGnsData calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetGnsAdditionalGnsData(ctx context.Context, displayName string) (result *GnsAdditionalGnsData, err error) {
	hashedName := helper.GetHashedName("additionalgnsdatas.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().GetAdditionalGnsDataByName(ctx, hashedName)
}

func (c *Clientset) GnsAdditionalGnsData(displayName string) *additionalgnsdataGnsTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["additionalgnsdatas.gns.tsm.tanzu.vmware.com"] = displayName
	return &additionalgnsdataGnsTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// AddGnsAdditionalGnsData calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddGnsAdditionalGnsData(ctx context.Context,
	objToCreate *basegnstsmtanzuvmwarecomv1.AdditionalGnsData) (result *GnsAdditionalGnsData, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Gns().CreateAdditionalGnsDataByName(ctx, objToCreate)
}

// DeleteGnsAdditionalGnsData calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeleteGnsAdditionalGnsData(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("additionalgnsdatas.gns.tsm.tanzu.vmware.com", nil, displayName)
	return c.Gns().DeleteAdditionalGnsDataByName(ctx, hashedName)
}

type additionalgnsdataGnsTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *additionalgnsdataGnsTsmV1Chainer) Subscribe() {
	key := "additionalgnsdatas.gns.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informergnstsmtanzuvmwarecomv1.NewAdditionalGnsDataInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *additionalgnsdataGnsTsmV1Chainer) Unsubscribe() {
	key := "additionalgnsdatas.gns.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *additionalgnsdataGnsTsmV1Chainer) IsSubscribed() bool {
	key := "additionalgnsdatas.gns.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// ClearStatus to clear user defined status
func (c *additionalgnsdataGnsTsmV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("additionalgnsdatas.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetAdditionalGnsDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetAdditionalGnsDataStatusByName(ctx, obj.AdditionalGnsData, nil)
	return err
}

// GetStatus to get user defined status
func (c *additionalgnsdataGnsTsmV1Chainer) GetStatus(ctx context.Context) (result *basegnstsmtanzuvmwarecomv1.AdditionalStatus, err error) {
	hashedName := helper.GetHashedName("additionalgnsdatas.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetAdditionalGnsDataByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *additionalgnsdataGnsTsmV1Chainer) SetStatus(ctx context.Context, status *basegnstsmtanzuvmwarecomv1.AdditionalStatus) (err error) {
	hashedName := helper.GetHashedName("additionalgnsdatas.gns.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Gns().GetAdditionalGnsDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Gns().SetAdditionalGnsDataStatusByName(ctx, obj.AdditionalGnsData, status)
	return err
}

// GetSvcGroupByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) GetSvcGroupByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroup, error) {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup)
		return &ServicegroupSvcGroup{
			client:   group.client,
			SvcGroup: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &ServicegroupSvcGroup{
			client:   group.client,
			SvcGroup: result,
		}, nil
	}
}

// DeleteSvcGroupByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) DeleteSvcGroupByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsServiceGroupsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSvcGroupByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ServicegroupTsmV1) CreateSvcGroupByName(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (*ServicegroupSvcGroup, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"gnsServiceGroupsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// UpdateSvcGroupByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ServicegroupTsmV1) UpdateSvcGroupByName(ctx context.Context,
	objToUpdate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroup) (*ServicegroupSvcGroup, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroups().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	patchValueColor :=
		objToUpdate.Spec.Color
	patchOpColor := PatchOp{
		Op:    "replace",
		Path:  "/spec/color",
		Value: patchValueColor,
	}
	patch = append(patch, patchOpColor)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroups().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroup{
		client:   group.client,
		SvcGroup: result,
	}, nil
}

// ListSvcGroups returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ServicegroupTsmV1) ListSvcGroups(ctx context.Context,
	opts metav1.ListOptions) (result []*ServicegroupSvcGroup, err error) {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ServicegroupSvcGroup, len(items))
		for k, v := range items {
			item, _ := v.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup)
			result[k] = &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ServicegroupTsmV1().
			SvcGroups().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ServicegroupSvcGroup, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ServicegroupSvcGroup{
				client:   group.client,
				SvcGroup: &item,
			}
		}
	}
	return
}

type ServicegroupSvcGroup struct {
	client *Clientset
	*baseservicegrouptsmtanzuvmwarecomv1.SvcGroup
}

// Delete removes obj and all it's children from the database.
func (obj *ServicegroupSvcGroup) Delete(ctx context.Context) error {
	err := obj.client.Servicegroup().DeleteSvcGroupByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroup = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ServicegroupSvcGroup) Update(ctx context.Context) error {
	result, err := obj.client.Servicegroup().UpdateSvcGroupByName(ctx, obj.SvcGroup)
	if err != nil {
		return err
	}
	obj.SvcGroup = result.SvcGroup
	return nil
}

func (obj *ServicegroupSvcGroup) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

type svcgroupServicegroupTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *svcgroupServicegroupTsmV1Chainer) Subscribe() {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *svcgroupServicegroupTsmV1Chainer) Unsubscribe() {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *svcgroupServicegroupTsmV1Chainer) IsSubscribed() bool {
	key := "svcgroups.servicegroup.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetSvcGroupLinkInfoByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) GetSvcGroupLinkInfoByName(ctx context.Context, hashedName string) (*ServicegroupSvcGroupLinkInfo, error) {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo)
		return &ServicegroupSvcGroupLinkInfo{
			client:           group.client,
			SvcGroupLinkInfo: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &ServicegroupSvcGroupLinkInfo{
			client:           group.client,
			SvcGroupLinkInfo: result,
		}, nil
	}
}

// DeleteSvcGroupLinkInfoByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ServicegroupTsmV1) DeleteSvcGroupLinkInfoByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroupLinkInfos().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroupLinkInfos().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/svcGrpInfoGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateSvcGroupLinkInfoByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ServicegroupTsmV1) CreateSvcGroupLinkInfoByName(ctx context.Context,
	objToCreate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (*ServicegroupSvcGroupLinkInfo, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroupLinkInfos().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/svcGrpInfoGvk",
		Value: baseservicegrouptsmtanzuvmwarecomv1.Child{
			Group: "servicegroup.tsm.tanzu.vmware.com",
			Kind:  "SvcGroupLinkInfo",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroupLinkInfo{
		client:           group.client,
		SvcGroupLinkInfo: result,
	}, nil
}

// UpdateSvcGroupLinkInfoByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ServicegroupTsmV1) UpdateSvcGroupLinkInfoByName(ctx context.Context,
	objToUpdate *baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo) (*ServicegroupSvcGroupLinkInfo, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			ServicegroupTsmV1().
			SvcGroupLinkInfos().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueClusterName :=
		objToUpdate.Spec.ClusterName
	patchOpClusterName := PatchOp{
		Op:    "replace",
		Path:  "/spec/clusterName",
		Value: patchValueClusterName,
	}
	patch = append(patch, patchOpClusterName)

	patchValueDomainName :=
		objToUpdate.Spec.DomainName
	patchOpDomainName := PatchOp{
		Op:    "replace",
		Path:  "/spec/domainName",
		Value: patchValueDomainName,
	}
	patch = append(patch, patchOpDomainName)

	patchValueServiceName :=
		objToUpdate.Spec.ServiceName
	patchOpServiceName := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceName",
		Value: patchValueServiceName,
	}
	patch = append(patch, patchOpServiceName)

	patchValueServiceType :=
		objToUpdate.Spec.ServiceType
	patchOpServiceType := PatchOp{
		Op:    "replace",
		Path:  "/spec/serviceType",
		Value: patchValueServiceType,
	}
	patch = append(patch, patchOpServiceType)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		ServicegroupTsmV1().
		SvcGroupLinkInfos().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &ServicegroupSvcGroupLinkInfo{
		client:           group.client,
		SvcGroupLinkInfo: result,
	}, nil
}

// ListSvcGroupLinkInfos returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ServicegroupTsmV1) ListSvcGroupLinkInfos(ctx context.Context,
	opts metav1.ListOptions) (result []*ServicegroupSvcGroupLinkInfo, err error) {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ServicegroupSvcGroupLinkInfo, len(items))
		for k, v := range items {
			item, _ := v.(*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo)
			result[k] = &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ServicegroupTsmV1().
			SvcGroupLinkInfos().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ServicegroupSvcGroupLinkInfo, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ServicegroupSvcGroupLinkInfo{
				client:           group.client,
				SvcGroupLinkInfo: &item,
			}
		}
	}
	return
}

type ServicegroupSvcGroupLinkInfo struct {
	client *Clientset
	*baseservicegrouptsmtanzuvmwarecomv1.SvcGroupLinkInfo
}

// Delete removes obj and all it's children from the database.
func (obj *ServicegroupSvcGroupLinkInfo) Delete(ctx context.Context) error {
	err := obj.client.Servicegroup().DeleteSvcGroupLinkInfoByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SvcGroupLinkInfo = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ServicegroupSvcGroupLinkInfo) Update(ctx context.Context) error {
	result, err := obj.client.Servicegroup().UpdateSvcGroupLinkInfoByName(ctx, obj.SvcGroupLinkInfo)
	if err != nil {
		return err
	}
	obj.SvcGroupLinkInfo = result.SvcGroupLinkInfo
	return nil
}

func (obj *ServicegroupSvcGroupLinkInfo) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type svcgrouplinkinfoServicegroupTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) Subscribe() {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerservicegrouptsmtanzuvmwarecomv1.NewSvcGroupLinkInfoInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) Unsubscribe() {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *svcgrouplinkinfoServicegroupTsmV1Chainer) IsSubscribed() bool {
	key := "svcgrouplinkinfos.servicegroup.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetAdditionalPolicyDataByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetAdditionalPolicyDataByName(ctx context.Context, hashedName string) (*PolicypkgAdditionalPolicyData, error) {
	key := "additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData)
		return &PolicypkgAdditionalPolicyData{
			client:               group.client,
			AdditionalPolicyData: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			AdditionalPolicyDatas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &PolicypkgAdditionalPolicyData{
			client:               group.client,
			AdditionalPolicyData: result,
		}, nil
	}
}

// DeleteAdditionalPolicyDataByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteAdditionalPolicyDataByName(ctx context.Context, hashedName string) (err error) {

	err = group.client.baseClient.
		PolicypkgTsmV1().
		AdditionalPolicyDatas().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAdditionalPolicyDataByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateAdditionalPolicyDataByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData) (*PolicypkgAdditionalPolicyData, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		AdditionalPolicyDatas().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicypkgAdditionalPolicyData{
		client:               group.client,
		AdditionalPolicyData: result,
	}, nil
}

// SetAdditionalPolicyDataStatusByName sets user defined status
func (group *PolicypkgTsmV1) SetAdditionalPolicyDataStatusByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData, status *basepolicypkgtsmtanzuvmwarecomv1.AdditionalStatus) (*PolicypkgAdditionalPolicyData, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		AdditionalPolicyDatas().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/status",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		PolicypkgTsmV1().
		AdditionalPolicyDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &PolicypkgAdditionalPolicyData{
		client:               group.client,
		AdditionalPolicyData: result,
	}, nil
}

// UpdateAdditionalPolicyDataByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateAdditionalPolicyDataByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData) (*PolicypkgAdditionalPolicyData, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicypkgTsmV1().
			AdditionalPolicyDatas().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		AdditionalPolicyDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicypkgAdditionalPolicyData{
		client:               group.client,
		AdditionalPolicyData: result,
	}, nil
}

// ListAdditionalPolicyDatas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListAdditionalPolicyDatas(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgAdditionalPolicyData, err error) {
	key := "additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgAdditionalPolicyData, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData)
			result[k] = &PolicypkgAdditionalPolicyData{
				client:               group.client,
				AdditionalPolicyData: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			AdditionalPolicyDatas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgAdditionalPolicyData, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgAdditionalPolicyData{
				client:               group.client,
				AdditionalPolicyData: &item,
			}
		}
	}
	return
}

type PolicypkgAdditionalPolicyData struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgAdditionalPolicyData) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteAdditionalPolicyDataByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AdditionalPolicyData = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgAdditionalPolicyData) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateAdditionalPolicyDataByName(ctx, obj.AdditionalPolicyData)
	if err != nil {
		return err
	}
	obj.AdditionalPolicyData = result.AdditionalPolicyData
	return nil
}

// SetStatus sets user defined status
func (obj *PolicypkgAdditionalPolicyData) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.AdditionalStatus) error {
	result, err := obj.client.Policypkg().SetAdditionalPolicyDataStatusByName(ctx, obj.AdditionalPolicyData, status)
	if err != nil {
		return err
	}
	obj.AdditionalPolicyData = result.AdditionalPolicyData
	return nil
}

// GetStatus to get user defined status
func (obj *PolicypkgAdditionalPolicyData) GetStatus(ctx context.Context) (*basepolicypkgtsmtanzuvmwarecomv1.AdditionalStatus, error) {
	getObj, err := obj.client.Policypkg().GetAdditionalPolicyDataByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *PolicypkgAdditionalPolicyData) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Policypkg().SetAdditionalPolicyDataStatusByName(ctx, obj.AdditionalPolicyData, &basepolicypkgtsmtanzuvmwarecomv1.AdditionalStatus{})
	if err != nil {
		return err
	}
	obj.AdditionalPolicyData = result.AdditionalPolicyData
	return nil
}

// GetPolicypkgAdditionalPolicyData calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetPolicypkgAdditionalPolicyData(ctx context.Context, displayName string) (result *PolicypkgAdditionalPolicyData, err error) {
	hashedName := helper.GetHashedName("additionalpolicydatas.policypkg.tsm.tanzu.vmware.com", nil, displayName)
	return c.Policypkg().GetAdditionalPolicyDataByName(ctx, hashedName)
}

func (c *Clientset) PolicypkgAdditionalPolicyData(displayName string) *additionalpolicydataPolicypkgTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"] = displayName
	return &additionalpolicydataPolicypkgTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// AddPolicypkgAdditionalPolicyData calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddPolicypkgAdditionalPolicyData(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AdditionalPolicyData) (result *PolicypkgAdditionalPolicyData, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Policypkg().CreateAdditionalPolicyDataByName(ctx, objToCreate)
}

// DeletePolicypkgAdditionalPolicyData calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeletePolicypkgAdditionalPolicyData(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("additionalpolicydatas.policypkg.tsm.tanzu.vmware.com", nil, displayName)
	return c.Policypkg().DeleteAdditionalPolicyDataByName(ctx, hashedName)
}

type additionalpolicydataPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *additionalpolicydataPolicypkgTsmV1Chainer) Subscribe() {
	key := "additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewAdditionalPolicyDataInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *additionalpolicydataPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *additionalpolicydataPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "additionalpolicydatas.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// ClearStatus to clear user defined status
func (c *additionalpolicydataPolicypkgTsmV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("additionalpolicydatas.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetAdditionalPolicyDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetAdditionalPolicyDataStatusByName(ctx, obj.AdditionalPolicyData, nil)
	return err
}

// GetStatus to get user defined status
func (c *additionalpolicydataPolicypkgTsmV1Chainer) GetStatus(ctx context.Context) (result *basepolicypkgtsmtanzuvmwarecomv1.AdditionalStatus, err error) {
	hashedName := helper.GetHashedName("additionalpolicydatas.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetAdditionalPolicyDataByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *additionalpolicydataPolicypkgTsmV1Chainer) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.AdditionalStatus) (err error) {
	hashedName := helper.GetHashedName("additionalpolicydatas.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetAdditionalPolicyDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetAdditionalPolicyDataStatusByName(ctx, obj.AdditionalPolicyData, status)
	return err
}

// GetAccessControlPolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetAccessControlPolicyByName(ctx context.Context, hashedName string) (*PolicypkgAccessControlPolicy, error) {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy)
		return &PolicypkgAccessControlPolicy{
			client:              group.client,
			AccessControlPolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &PolicypkgAccessControlPolicy{
			client:              group.client,
			AccessControlPolicy: result,
		}, nil
	}
}

// DeleteAccessControlPolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteAccessControlPolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		AccessControlPolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	for _, v := range result.Spec.PolicyConfigsGvk {
		err := group.client.
			Policypkg().DeleteACPConfigByName(ctx, v.Name)
		if err != nil {
			return err
		}
	}

	err = group.client.baseClient.
		PolicypkgTsmV1().
		AccessControlPolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/gnsAccessControlPolicyGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateAccessControlPolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateAccessControlPolicyByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (*PolicypkgAccessControlPolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.PolicyConfigsGvk = nil

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		AccessControlPolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["gnses.gns.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/gnsAccessControlPolicyGvk",
		Value: basepolicypkgtsmtanzuvmwarecomv1.Child{
			Group: "policypkg.tsm.tanzu.vmware.com",
			Kind:  "AccessControlPolicy",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		GnsTsmV1().
		Gnses().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicypkgAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// UpdateAccessControlPolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateAccessControlPolicyByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy) (*PolicypkgAccessControlPolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicypkgTsmV1().
			AccessControlPolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		AccessControlPolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicypkgAccessControlPolicy{
		client:              group.client,
		AccessControlPolicy: result,
	}, nil
}

// ListAccessControlPolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListAccessControlPolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgAccessControlPolicy, err error) {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgAccessControlPolicy, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy)
			result[k] = &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			AccessControlPolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgAccessControlPolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgAccessControlPolicy{
				client:              group.client,
				AccessControlPolicy: &item,
			}
		}
	}
	return
}

type PolicypkgAccessControlPolicy struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.AccessControlPolicy
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgAccessControlPolicy) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteAccessControlPolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgAccessControlPolicy) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateAccessControlPolicyByName(ctx, obj.AccessControlPolicy)
	if err != nil {
		return err
	}
	obj.AccessControlPolicy = result.AccessControlPolicy
	return nil
}

func (obj *PolicypkgAccessControlPolicy) GetParent(ctx context.Context) (result *GnsGns, err error) {
	hashedName := helper.GetHashedName("gnses.gns.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["gnses.gns.tsm.tanzu.vmware.com"])
	return obj.client.Gns().GetGnsByName(ctx, hashedName)
}

// GetAllPolicyConfigs returns all children of given type
func (obj *PolicypkgAccessControlPolicy) GetAllPolicyConfigs(ctx context.Context) (
	result []*PolicypkgACPConfig, err error) {
	result = make([]*PolicypkgACPConfig, 0, len(obj.Spec.PolicyConfigsGvk))
	for _, v := range obj.Spec.PolicyConfigsGvk {
		l, err := obj.client.Policypkg().GetACPConfigByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPolicyConfigs returns child which has given displayName
func (obj *PolicypkgAccessControlPolicy) GetPolicyConfigs(ctx context.Context,
	displayName string) (result *PolicypkgACPConfig, err error) {
	l, ok := obj.Spec.PolicyConfigsGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Policypkg.AccessControlPolicy", "PolicyConfigs", displayName)
	}
	result, err = obj.client.Policypkg().GetACPConfigByName(ctx, l.Name)
	return
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *PolicypkgAccessControlPolicy) AddPolicyConfigs(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (result *PolicypkgACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Policypkg().CreateACPConfigByName(ctx, objToCreate)
	updatedObj, getErr := obj.client.Policypkg().GetAccessControlPolicyByName(ctx, obj.GetName())
	if getErr == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *PolicypkgAccessControlPolicy) DeletePolicyConfigs(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.PolicyConfigsGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Policypkg.AccessControlPolicy", "PolicyConfigs", displayName)
	}
	err = obj.client.Policypkg().DeleteACPConfigByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.Policypkg().GetAccessControlPolicyByName(ctx, obj.GetName())
	if err == nil {
		obj.AccessControlPolicy = updatedObj.AccessControlPolicy
	}
	return
}

type accesscontrolpolicyPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) Subscribe() {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewAccessControlPolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) PolicyConfigs(name string) *acpconfigPolicypkgTsmV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["acpconfigs.policypkg.tsm.tanzu.vmware.com"] = name
	return &acpconfigPolicypkgTsmV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPolicyConfigs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) GetPolicyConfigs(ctx context.Context, displayName string) (result *PolicypkgACPConfig, err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, displayName)
	return c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
}

// AddPolicyConfigs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) AddPolicyConfigs(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (result *PolicypkgACPConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Policypkg().CreateACPConfigByName(ctx, objToCreate)
}

// DeletePolicyConfigs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *accesscontrolpolicyPolicypkgTsmV1Chainer) DeletePolicyConfigs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, name)
	return c.client.Policypkg().DeleteACPConfigByName(ctx, hashedName)
}

// GetACPConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetACPConfigByName(ctx context.Context, hashedName string) (*PolicypkgACPConfig, error) {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig)
		return &PolicypkgACPConfig{
			client:    group.client,
			ACPConfig: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &PolicypkgACPConfig{
			client:    group.client,
			ACPConfig: result,
		}, nil
	}
}

// DeleteACPConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteACPConfigByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		ACPConfigs().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		PolicypkgTsmV1().
		ACPConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/policyConfigsGvk/" + result.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		PolicypkgTsmV1().
		AccessControlPolicies().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateACPConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateACPConfigByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (*PolicypkgACPConfig, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.DestSvcGroupsGvk = nil
	objToCreate.Spec.SourceSvcGroupsGvk = nil

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		ACPConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	payload := "{\"spec\": {\"policyConfigsGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"ACPConfig\", \"group\": \"policypkg.tsm.tanzu.vmware.com\"}}}}"
	_, err = group.client.baseClient.
		PolicypkgTsmV1().
		AccessControlPolicies().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicypkgACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// SetACPConfigStatusByName sets user defined status
func (group *PolicypkgTsmV1) SetACPConfigStatusByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig, status *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus) (*PolicypkgACPConfig, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		ACPConfigs().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/status",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		PolicypkgTsmV1().
		ACPConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &PolicypkgACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// UpdateACPConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateACPConfigByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.ACPConfig) (*PolicypkgACPConfig, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicypkgTsmV1().
			ACPConfigs().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDisplayName :=
		objToUpdate.Spec.DisplayName
	patchOpDisplayName := PatchOp{
		Op:    "replace",
		Path:  "/spec/displayName",
		Value: patchValueDisplayName,
	}
	patch = append(patch, patchOpDisplayName)

	patchValueGns :=
		objToUpdate.Spec.Gns
	patchOpGns := PatchOp{
		Op:    "replace",
		Path:  "/spec/gns",
		Value: patchValueGns,
	}
	patch = append(patch, patchOpGns)

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	if objToUpdate.Spec.Tags != nil {
		patchValueTags :=
			objToUpdate.Spec.Tags
		patchOpTags := PatchOp{
			Op:    "replace",
			Path:  "/spec/tags",
			Value: patchValueTags,
		}
		patch = append(patch, patchOpTags)
	}

	patchValueProjectId :=
		objToUpdate.Spec.ProjectId
	patchOpProjectId := PatchOp{
		Op:    "replace",
		Path:  "/spec/projectId",
		Value: patchValueProjectId,
	}
	patch = append(patch, patchOpProjectId)

	if objToUpdate.Spec.Conditions != nil {
		patchValueConditions :=
			objToUpdate.Spec.Conditions
		patchOpConditions := PatchOp{
			Op:    "replace",
			Path:  "/spec/conditions",
			Value: patchValueConditions,
		}
		patch = append(patch, patchOpConditions)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		ACPConfigs().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicypkgACPConfig{
		client:    group.client,
		ACPConfig: result,
	}, nil
}

// ListACPConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListACPConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgACPConfig, err error) {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgACPConfig, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig)
			result[k] = &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			ACPConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgACPConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgACPConfig{
				client:    group.client,
				ACPConfig: &item,
			}
		}
	}
	return
}

type PolicypkgACPConfig struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.ACPConfig
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgACPConfig) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteACPConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ACPConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgACPConfig) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateACPConfigByName(ctx, obj.ACPConfig)
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

// SetStatus sets user defined status
func (obj *PolicypkgACPConfig) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus) error {
	result, err := obj.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, status)
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

// GetStatus to get user defined status
func (obj *PolicypkgACPConfig) GetStatus(ctx context.Context) (*basepolicypkgtsmtanzuvmwarecomv1.ACPStatus, error) {
	getObj, err := obj.client.Policypkg().GetACPConfigByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *PolicypkgACPConfig) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, &basepolicypkgtsmtanzuvmwarecomv1.ACPStatus{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result.ACPConfig
	return nil
}

func (obj *PolicypkgACPConfig) GetParent(ctx context.Context) (result *PolicypkgAccessControlPolicy, err error) {
	hashedName := helper.GetHashedName("accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["accesscontrolpolicies.policypkg.tsm.tanzu.vmware.com"])
	return obj.client.Policypkg().GetAccessControlPolicyByName(ctx, hashedName)
}

// GetAllDestSvcGroups returns all links of given type
func (obj *PolicypkgACPConfig) GetAllDestSvcGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.DestSvcGroupsGvk))
	for _, v := range obj.Spec.DestSvcGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetDestSvcGroups returns link which has given displayName
func (obj *PolicypkgACPConfig) GetDestSvcGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.DestSvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Policypkg.ACPConfig", "DestSvcGroups", displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkDestSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *PolicypkgACPConfig) LinkDestSvcGroups(ctx context.Context,
	linkToAdd *ServicegroupSvcGroup) error {

	payload := "{\"spec\": {\"destSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkDestSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *PolicypkgACPConfig) UnlinkDestSvcGroups(ctx context.Context,
	linkToRemove *ServicegroupSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/destSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

// GetAllSourceSvcGroups returns all links of given type
func (obj *PolicypkgACPConfig) GetAllSourceSvcGroups(ctx context.Context) (
	result []*ServicegroupSvcGroup, err error) {
	result = make([]*ServicegroupSvcGroup, 0, len(obj.Spec.SourceSvcGroupsGvk))
	for _, v := range obj.Spec.SourceSvcGroupsGvk {
		l, err := obj.client.Servicegroup().GetSvcGroupByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetSourceSvcGroups returns link which has given displayName
func (obj *PolicypkgACPConfig) GetSourceSvcGroups(ctx context.Context,
	displayName string) (result *ServicegroupSvcGroup, err error) {
	l, ok := obj.Spec.SourceSvcGroupsGvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "Policypkg.ACPConfig", "SourceSvcGroups", displayName)
	}
	result, err = obj.client.Servicegroup().GetSvcGroupByName(ctx, l.Name)
	return
}

// LinkSourceSvcGroups links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *PolicypkgACPConfig) LinkSourceSvcGroups(ctx context.Context,
	linkToAdd *ServicegroupSvcGroup) error {

	payload := "{\"spec\": {\"sourceSvcGroupsGvk\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"SvcGroup\", \"group\": \"servicegroup.tsm.tanzu.vmware.com\"}}}}"
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.ACPConfig = result
	return nil
}

// UnlinkSourceSvcGroups unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *PolicypkgACPConfig) UnlinkSourceSvcGroups(ctx context.Context,
	linkToRemove *ServicegroupSvcGroup) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/sourceSvcGroupsGvk/" + linkToRemove.DisplayName(),
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.PolicypkgTsmV1().ACPConfigs().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.ACPConfig = result
	return nil

}

type acpconfigPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *acpconfigPolicypkgTsmV1Chainer) Subscribe() {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewACPConfigInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *acpconfigPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *acpconfigPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "acpconfigs.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// ClearStatus to clear user defined status
func (c *acpconfigPolicypkgTsmV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, nil)
	return err
}

// GetStatus to get user defined status
func (c *acpconfigPolicypkgTsmV1Chainer) GetStatus(ctx context.Context) (result *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus, err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *acpconfigPolicypkgTsmV1Chainer) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.ACPStatus) (err error) {
	hashedName := helper.GetHashedName("acpconfigs.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetACPConfigByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetACPConfigStatusByName(ctx, obj.ACPConfig, status)
	return err
}

// GetVMpolicyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetVMpolicyByName(ctx context.Context, hashedName string) (*PolicypkgVMpolicy, error) {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy)
		return &PolicypkgVMpolicy{
			client:   group.client,
			VMpolicy: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &PolicypkgVMpolicy{
			client:   group.client,
			VMpolicy: result,
		}, nil
	}
}

// DeleteVMpolicyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteVMpolicyByName(ctx context.Context, hashedName string) (err error) {

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		VMpolicies().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}

	err = group.client.baseClient.
		PolicypkgTsmV1().
		VMpolicies().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/vMPPoliciesGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", parents, parentName)
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateVMpolicyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateVMpolicyByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (*PolicypkgVMpolicy, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		VMpolicies().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.tsm.tanzu.vmware.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", objToCreate.GetLabels(), parentName)
	}

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/vMPPoliciesGvk",
		Value: basepolicypkgtsmtanzuvmwarecomv1.Child{
			Group: "policypkg.tsm.tanzu.vmware.com",
			Kind:  "VMpolicy",
			Name:  objToCreate.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
		ConfigTsmV1().
		Configs().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicypkgVMpolicy{
		client:   group.client,
		VMpolicy: result,
	}, nil
}

// UpdateVMpolicyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateVMpolicyByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.VMpolicy) (*PolicypkgVMpolicy, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicypkgTsmV1().
			VMpolicies().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		VMpolicies().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicypkgVMpolicy{
		client:   group.client,
		VMpolicy: result,
	}, nil
}

// ListVMpolicies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListVMpolicies(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgVMpolicy, err error) {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgVMpolicy, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy)
			result[k] = &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			VMpolicies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgVMpolicy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgVMpolicy{
				client:   group.client,
				VMpolicy: &item,
			}
		}
	}
	return
}

type PolicypkgVMpolicy struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.VMpolicy
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgVMpolicy) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteVMpolicyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.VMpolicy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgVMpolicy) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateVMpolicyByName(ctx, obj.VMpolicy)
	if err != nil {
		return err
	}
	obj.VMpolicy = result.VMpolicy
	return nil
}

func (obj *PolicypkgVMpolicy) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.tsm.tanzu.vmware.com", obj.Labels, obj.Labels["configs.config.tsm.tanzu.vmware.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type vmpolicyPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *vmpolicyPolicypkgTsmV1Chainer) Subscribe() {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewVMpolicyInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *vmpolicyPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *vmpolicyPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "vmpolicies.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// GetRandomPolicyDataByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) GetRandomPolicyDataByName(ctx context.Context, hashedName string) (*PolicypkgRandomPolicyData, error) {
	key := "randompolicydatas.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists, err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

		result, _ := item.(*basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData)
		return &PolicypkgRandomPolicyData{
			client:           group.client,
			RandomPolicyData: result,
		}, nil
	} else {
		result, err := group.client.baseClient.
			PolicypkgTsmV1().
			RandomPolicyDatas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &PolicypkgRandomPolicyData{
			client:           group.client,
			RandomPolicyData: result,
		}, nil
	}
}

// DeleteRandomPolicyDataByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *PolicypkgTsmV1) DeleteRandomPolicyDataByName(ctx context.Context, hashedName string) (err error) {

	err = group.client.baseClient.
		PolicypkgTsmV1().
		RandomPolicyDatas().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	return
}

// CreateRandomPolicyDataByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *PolicypkgTsmV1) CreateRandomPolicyDataByName(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData) (*PolicypkgRandomPolicyData, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		RandomPolicyDatas().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	return &PolicypkgRandomPolicyData{
		client:           group.client,
		RandomPolicyData: result,
	}, nil
}

// SetRandomPolicyDataStatusByName sets user defined status
func (group *PolicypkgTsmV1) SetRandomPolicyDataStatusByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData, status *basepolicypkgtsmtanzuvmwarecomv1.RandomStatus) (*PolicypkgRandomPolicyData, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		RandomPolicyDatas().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
		PatchOp{
			Op:    "replace",
			Path:  "/status/status",
			Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
		PolicypkgTsmV1().
		RandomPolicyDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &PolicypkgRandomPolicyData{
		client:           group.client,
		RandomPolicyData: result,
	}, nil
}

// UpdateRandomPolicyDataByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *PolicypkgTsmV1) UpdateRandomPolicyDataByName(ctx context.Context,
	objToUpdate *basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData) (*PolicypkgRandomPolicyData, error) {

	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
			PolicypkgTsmV1().
			RandomPolicyDatas().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})

	patchValueDescription :=
		objToUpdate.Spec.Description
	patchOpDescription := PatchOp{
		Op:    "replace",
		Path:  "/spec/description",
		Value: patchValueDescription,
	}
	patch = append(patch, patchOpDescription)

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
		PolicypkgTsmV1().
		RandomPolicyDatas().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &PolicypkgRandomPolicyData{
		client:           group.client,
		RandomPolicyData: result,
	}, nil
}

// ListRandomPolicyDatas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *PolicypkgTsmV1) ListRandomPolicyDatas(ctx context.Context,
	opts metav1.ListOptions) (result []*PolicypkgRandomPolicyData, err error) {
	key := "randompolicydatas.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*PolicypkgRandomPolicyData, len(items))
		for k, v := range items {
			item, _ := v.(*basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData)
			result[k] = &PolicypkgRandomPolicyData{
				client:           group.client,
				RandomPolicyData: item,
			}
		}
	} else {
		list, err := group.client.baseClient.PolicypkgTsmV1().
			RandomPolicyDatas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*PolicypkgRandomPolicyData, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &PolicypkgRandomPolicyData{
				client:           group.client,
				RandomPolicyData: &item,
			}
		}
	}
	return
}

type PolicypkgRandomPolicyData struct {
	client *Clientset
	*basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData
}

// Delete removes obj and all it's children from the database.
func (obj *PolicypkgRandomPolicyData) Delete(ctx context.Context) error {
	err := obj.client.Policypkg().DeleteRandomPolicyDataByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RandomPolicyData = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *PolicypkgRandomPolicyData) Update(ctx context.Context) error {
	result, err := obj.client.Policypkg().UpdateRandomPolicyDataByName(ctx, obj.RandomPolicyData)
	if err != nil {
		return err
	}
	obj.RandomPolicyData = result.RandomPolicyData
	return nil
}

// SetStatus sets user defined status
func (obj *PolicypkgRandomPolicyData) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.RandomStatus) error {
	result, err := obj.client.Policypkg().SetRandomPolicyDataStatusByName(ctx, obj.RandomPolicyData, status)
	if err != nil {
		return err
	}
	obj.RandomPolicyData = result.RandomPolicyData
	return nil
}

// GetStatus to get user defined status
func (obj *PolicypkgRandomPolicyData) GetStatus(ctx context.Context) (*basepolicypkgtsmtanzuvmwarecomv1.RandomStatus, error) {
	getObj, err := obj.client.Policypkg().GetRandomPolicyDataByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *PolicypkgRandomPolicyData) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Policypkg().SetRandomPolicyDataStatusByName(ctx, obj.RandomPolicyData, &basepolicypkgtsmtanzuvmwarecomv1.RandomStatus{})
	if err != nil {
		return err
	}
	obj.RandomPolicyData = result.RandomPolicyData
	return nil
}

// GetPolicypkgRandomPolicyData calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) GetPolicypkgRandomPolicyData(ctx context.Context, displayName string) (result *PolicypkgRandomPolicyData, err error) {
	hashedName := helper.GetHashedName("randompolicydatas.policypkg.tsm.tanzu.vmware.com", nil, displayName)
	return c.Policypkg().GetRandomPolicyDataByName(ctx, hashedName)
}

func (c *Clientset) PolicypkgRandomPolicyData(displayName string) *randompolicydataPolicypkgTsmV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["randompolicydatas.policypkg.tsm.tanzu.vmware.com"] = displayName
	return &randompolicydataPolicypkgTsmV1Chainer{
		client:       c,
		name:         displayName,
		parentLabels: parentLabels,
	}
}

// AddPolicypkgRandomPolicyData calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddPolicypkgRandomPolicyData(ctx context.Context,
	objToCreate *basepolicypkgtsmtanzuvmwarecomv1.RandomPolicyData) (result *PolicypkgRandomPolicyData, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Policypkg().CreateRandomPolicyDataByName(ctx, objToCreate)
}

// DeletePolicypkgRandomPolicyData calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) DeletePolicypkgRandomPolicyData(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("randompolicydatas.policypkg.tsm.tanzu.vmware.com", nil, displayName)
	return c.Policypkg().DeleteRandomPolicyDataByName(ctx, hashedName)
}

type randompolicydataPolicypkgTsmV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *randompolicydataPolicypkgTsmV1Chainer) Subscribe() {
	key := "randompolicydatas.policypkg.tsm.tanzu.vmware.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerpolicypkgtsmtanzuvmwarecomv1.NewRandomPolicyDataInformer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *randompolicydataPolicypkgTsmV1Chainer) Unsubscribe() {
	key := "randompolicydatas.policypkg.tsm.tanzu.vmware.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *randompolicydataPolicypkgTsmV1Chainer) IsSubscribed() bool {
	key := "randompolicydatas.policypkg.tsm.tanzu.vmware.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

// ClearStatus to clear user defined status
func (c *randompolicydataPolicypkgTsmV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("randompolicydatas.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetRandomPolicyDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetRandomPolicyDataStatusByName(ctx, obj.RandomPolicyData, nil)
	return err
}

// GetStatus to get user defined status
func (c *randompolicydataPolicypkgTsmV1Chainer) GetStatus(ctx context.Context) (result *basepolicypkgtsmtanzuvmwarecomv1.RandomStatus, err error) {
	hashedName := helper.GetHashedName("randompolicydatas.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetRandomPolicyDataByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *randompolicydataPolicypkgTsmV1Chainer) SetStatus(ctx context.Context, status *basepolicypkgtsmtanzuvmwarecomv1.RandomStatus) (err error) {
	hashedName := helper.GetHashedName("randompolicydatas.policypkg.tsm.tanzu.vmware.com", c.parentLabels, c.name)
	obj, err := c.client.Policypkg().GetRandomPolicyDataByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Policypkg().SetRandomPolicyDataStatusByName(ctx, obj.RandomPolicyData, status)
	return err
}
