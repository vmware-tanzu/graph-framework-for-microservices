// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"sync"
	"fmt"
	"time"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

{{.HelperImport}}
{{.CommonImport}}
baseClientset {{.BaseClientsetImport}}
fakeBaseClienset {{.FakeBaseCliensetImport}}

{{.BaseImports}}
{{.InformerImports}}
)

type Clientset struct {
	baseClient baseClientset.Interface
	{{ range $key, $group := .ApiGroups }}{{$group.ClientsetApiGroups}}{{ end }}
}

type subscription struct {
	informer cache.SharedIndexInformer
	stop chan struct{}
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer){
	s:=subscription{
		informer: informer,
		stop: make(chan struct{}),
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key,s)
}

func (c *Clientset) SubscribeAll() {	
	var key string
	{{ range $key, $node := .Nodes }}
	key = "{{$node.CrdName}}"
	if _,ok := subscriptionMap.Load(key); !ok {
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
	{{end}}
}

func (c *Clientset) UnsubscribeAll() {
    subscriptionMap.Range(func(key, s interface{})bool{
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}
	client := &Clientset{}
	client.baseClient = baseClient
	{{ range $key, $group := .ApiGroups }}{{$group.InitApiGroups}}{{ end }}

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	{{ range $key, $group := .ApiGroups }}{{$group.InitApiGroups}}{{ end }}
	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

{{ range $key, $group := .ApiGroups }}{{$group.ClientsetsApiGroupMethods}}{{ end }}

{{ range $key, $group := .ApiGroups }}
type
{{$group.GroupTypeName}} struct {
client *Clientset
}

func new{{$group.GroupTypeName}}(client *Clientset) *{{$group.GroupTypeName}} {
	return &{{$group.GroupTypeName}}{
		client: client,
	}
}
{{end}}


{{ range $key, $node := .Nodes }}
// Get{{$node.BaseNodeName}}ByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) Get{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		item, exists,err := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if !exists {
			return nil, err
		}

        
		result, _ := item.(*{{$node.GroupBaseImport}})
		return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: group.client,
			{{$node.BaseNodeName}}: result,
		}, nil
	}else{
		result, err := group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			return nil, err
		}

		return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: group.client,
			{{$node.BaseNodeName}}: result,
		}, nil
	}
}

// ForceRead{{$node.BaseNodeName}}ByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) ForceRead{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}

	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

// Delete{{$node.BaseNodeName}}ByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) Delete{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (err error) {
	{{if or .HasChildren .Parent.HasParent }}
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
	if err != nil {
		return err
	}
	{{ end }}

	{{ range $key, $link := .Children }}
	{{ if $link.IsNamed }}
	for _, v := range result.Spec.{{$link.FieldName}}Gvk {
		err := group.client.
		{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, v.Name)
		if err != nil {
			if errors.IsNotFound(err) {
				continue
			}else{
				return err
			}
		}
	}
	{{ else }}
	if result.Spec.{{$link.FieldName}}Gvk != nil {
		err := group.client.
		{{$link.SimpleGroupTypeName}}().
		Delete{{$link.BaseNodeName}}ByName(ctx, result.Spec.{{$link.FieldName}}Gvk.Name)
		if err != nil && !errors.IsNotFound(err) {
			return err
		}
	}
	{{ end }}
	{{ end }}

	err = group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Delete(ctx, hashedName, metav1.DeleteOptions{})
	if err != nil {
		return err
	}

	{{if .Parent.HasParent}}
	var patch Patch
	{{if .Parent.IsNamed}}
	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/{{$node.Parent.GvkFieldName}}/" + result.DisplayName(),
	}
	{{ else }}
	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/{{$node.Parent.GvkFieldName}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if parents[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", parents, parentName)
	}
	_, err = group.client.baseClient.
	{{$node.Parent.GroupTypeName}}().
	{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	{{ end }}

	return
}

// Create{{$node.BaseNodeName}}ByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *{{$node.GroupTypeName}}) Create{{$node.BaseNodeName}}ByName(ctx context.Context,
	objToCreate *{{$node.GroupBaseImport}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	{{if $node.IsSingleton }}if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}{{end}}

	{{ range $key, $link := .LinksAndChildren }}objToCreate.Spec.{{$link.FieldName}}Gvk = nil
	{{ end }}
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Create(ctx, objToCreate, metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}

	{{if .Parent.HasParent}}
	parentName, ok := objToCreate.GetLabels()["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", objToCreate.GetLabels(), parentName)
	}
	{{if .Parent.IsNamed}}
	payload := "{\"spec\": {\"{{$node.Parent.GvkFieldName}}\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"{{$node.Kind}}\", \"group\": \"{{$node.Group}}\"}}}}"
	_, err = group.client.baseClient.
	{{$node.Parent.GroupTypeName}}().
	{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/{{$node.Parent.GvkFieldName}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$node.Group}}",
		Kind:  "{{$node.Kind}}",
		Name:  objToCreate.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	_, err = group.client.baseClient.
	{{$node.Parent.GroupTypeName}}().
	{{$node.Parent.GroupResourceNameTitle}}().Patch(ctx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return nil, err
	}
	{{ end }}
	{{ end }}

	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

{{if .HasStatus}}
// Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName sets user defined status
func (group *{{$node.GroupTypeName}}) Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx context.Context,
	objToUpdate *{{$node.GroupBaseImport}}, status *{{$node.BaseImportName}}.{{$node.StatusType}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {

	// Make sure status field is present first
	m := []byte("{\"status\":{}}")
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Patch(ctx, objToUpdate.GetName(), types.MergePatchType, m, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}

	patch := Patch{
	PatchOp{
		Op:    "replace",
		Path:  "/status/{{$node.StatusNameFirstLower}}",
		Value: status,
		},
	}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err = group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "status")
	if err != nil {
		return nil, err
	}
	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}
{{ end }}

// Update{{$node.BaseNodeName}}ByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *{{$node.GroupTypeName}}) Update{{$node.BaseNodeName}}ByName(ctx context.Context,
	objToUpdate *{{$node.GroupBaseImport}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	{{if $node.IsSingleton }}if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}{{end}}
	// ResourceVersion must be set for update
	if objToUpdate.ResourceVersion == "" {
		current, err := group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Get(ctx, objToUpdate.GetName(), metav1.GetOptions{})
		if err != nil {
			return nil, err
		}
		objToUpdate.ResourceVersion = current.ResourceVersion
	}

	var patch Patch
	patch = append(patch, PatchOp{
		Op:    "replace",
		Path:  "/metadata",
		Value: objToUpdate.ObjectMeta,
	})
	{{ range $key, $field := .Fields }}
	{{ if $field.IsAggregateKind }}
	if objToUpdate.Spec.{{$field.FieldName}} != nil {
		patchValue{{$field.FieldName}} :=
		objToUpdate.Spec.{{$field.FieldName}}
			patchOp{{$field.FieldName}} := PatchOp{
			Op:    "replace",
			Path:  "/spec/{{$field.FieldNameTag}}",
			Value: patchValue{{$field.FieldName}},
		}
		patch = append(patch, patchOp{{$field.FieldName}})
	}
	{{else}}
	patchValue{{$field.FieldName}} :=
	objToUpdate.Spec.{{$field.FieldName}}
		patchOp{{$field.FieldName}} := PatchOp{
		Op:    "replace",
		Path:  "/spec/{{$field.FieldNameTag}}",
		Value: patchValue{{$field.FieldName}},
	}
	patch = append(patch, patchOp{{$field.FieldName}})
	{{ end }}
	{{ end }}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}
	result, err := group.client.baseClient.
	{{$node.GroupTypeName}}().
	{{$node.GroupResourceNameTitle}}().Patch(ctx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
	if err != nil {
		return nil, err
	}

	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
	client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

// List{{$node.GroupResourceNameTitle}} returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *{{$node.GroupTypeName}}) List{{$node.GroupResourceNameTitle}}(ctx context.Context,
	opts metav1.ListOptions) (result []*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	key := "{{$node.CrdName}}"
	if s,ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, len(items))
		for k, v := range items {
			item, _ := v.(*{{$node.GroupBaseImport}})
			result[k] = &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: group.client,
				{{$node.BaseNodeName}}: item,
			}
		}
	} else {
		list, err := group.client.baseClient.{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: group.client,
				{{$node.BaseNodeName}}: &item,
			}
		}
	}
	return
}

type {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} struct {
	client *Clientset
	*{{$node.GroupBaseImport}}
}

// Delete removes obj and all it's children from the database.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete(ctx context.Context) error {
	err := obj.client.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Update(ctx context.Context) error {
	result, err := obj.client.{{$node.SimpleGroupTypeName}}().Update{{$node.BaseNodeName}}ByName(ctx, obj.{{$node.BaseNodeName}})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result.{{$node.BaseNodeName}}
	return nil
}

{{if .HasStatus}}
// Set{{.StatusName}} sets user defined status
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Set{{.StatusName}}(ctx context.Context, status *{{$node.BaseImportName}}.{{$node.StatusType}}) error {
	result, err := obj.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, status)
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result.{{$node.BaseNodeName}}
	return nil
}

// Get{{$node.StatusName}} to get user defined status
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$node.StatusName}}(ctx context.Context) (*{{$node.BaseImportName}}.{{$node.StatusType}}, error) {
	getObj, err := obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.{{$node.StatusName}}, nil
}

// Clear{{$node.StatusName}} to clear user defined status
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Clear{{$node.StatusName}}(ctx context.Context) error {
	result, err := obj.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, &{{$node.BaseImportName}}.{{$node.StatusType}}{})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result.{{$node.BaseNodeName}}
	return nil
}
{{ end }}

{{ if .Parent.HasParent }}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetParent(ctx context.Context) (result *{{$node.Parent.SimpleGroupTypeName}}{{$node.Parent.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.Parent.CrdName}}", obj.Labels, obj.Labels["{{$node.Parent.CrdName}}"])
	return obj.client.{{$node.Parent.SimpleGroupTypeName}}().Get{{$node.Parent.BaseNodeName}}ByName(ctx, hashedName)
}
{{ end }}

{{ if not .Parent.HasParent }}
{{ if $node.IsSingleton}}
// Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates the hashed name based on parents and
// returns given object
func (c *Clientset) Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, helper.DEFAULT_KEY)
	return c.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
}

func (c *Clientset) {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}() *{{$node.GroupResourceType}}Chainer {
	parentLabels := make(map[string]string)
	parentLabels["{{$node.CrdName}}"] = helper.DEFAULT_KEY
	return &{{$node.GroupResourceType}}Chainer{
		client:       c,
		name:  helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}
// Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context,
		objToCreate *{{$node.GroupBaseImport}}) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.{{$node.SimpleGroupTypeName}}().Create{{$node.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, helper.DEFAULT_KEY)
	return c.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, hashedName)
}
{{ else }}
// Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context, displayName string) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, displayName)
	return c.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
}

func (c *Clientset) {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(displayName string) *{{$node.GroupResourceType}}Chainer {
	parentLabels := make(map[string]string)
	parentLabels["{{$node.CrdName}}"] = displayName
	return &{{$node.GroupResourceType}}Chainer{
		client:       c,
		name:  displayName,
		parentLabels: parentLabels,
	}
}
// Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context,
		objToCreate *{{$node.GroupBaseImport}}) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.{{$node.SimpleGroupTypeName}}().Create{{$node.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, displayName)
	return c.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, hashedName)
}
{{ end }}
{{ end }}

{{ range $key, $link := .Children }}
{{ if $link.IsNamed }}
// GetAll{{$link.FieldName}} returns all children of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetAll{{$link.FieldName}}(ctx context.Context) (
		result []*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	result = make([]*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, 0, len(obj.Spec.{{$link.FieldName}}Gvk))
	for _, v := range obj.Spec.{{$link.FieldName}}Gvk {
		l, err := obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// Get{{$link.FieldName}} returns child which has given displayName
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context,
		displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	l, ok := obj.Spec.{{$link.FieldName}}Gvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}", displayName)
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, l.Name)
	return
}

{{ else }}
// Get{{$link.FieldName}} returns child of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context) (
		result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if obj.Spec.{{$link.FieldName}}Gvk == nil {
		return nil, NewChildNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}")
	}
	return obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, obj.Spec.{{$link.FieldName}}Gvk.Name)
}
{{ end }}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Add{{$link.FieldName}}(ctx context.Context,
	objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["{{$node.CrdName}}"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["{{$node.CrdName}}"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" { {{ if $link.IsSingleton}}
	if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}{{ end }}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
	updatedObj, getErr :=  obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if getErr == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
{{ if $link.IsNamed }}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete{{$link.FieldName}}(ctx context.Context, displayName string) (err error) {
	l, ok := obj.Spec.{{$link.FieldName}}Gvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}", displayName)
	}
	err = obj.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, l.Name)
	if err != nil {
		return err
	}
	updatedObj, err := obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}
{{ else}}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete{{$link.FieldName}}(ctx context.Context) (err error) {
	if obj.Spec.{{$link.FieldName}}Gvk != nil {
		err = obj.client.
		{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, obj.Spec.{{$link.FieldName}}Gvk.Name)
		if err != nil {
			return err
		}
	}
	updatedObj, err := obj.client.
	{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}
{{ end }}
{{ end }}

{{ range $key, $link := .Links }}
{{ if $link.IsNamed }}
// GetAll{{$link.FieldName}} returns all links of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetAll{{$link.FieldName}}(ctx context.Context) (
		result []*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	result = make([]*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, 0, len(obj.Spec.{{$link.FieldName}}Gvk))
	for _, v := range obj.Spec.{{$link.FieldName}}Gvk {
		l, err := obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// Get{{$link.FieldName}} returns link which has given displayName
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context,
		displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	l, ok := obj.Spec.{{$link.FieldName}}Gvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}", displayName)
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, l.Name)
	return
}

{{ else }}
// Get{{$link.FieldName}} returns link of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context) (
		result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if obj.Spec.{{$link.FieldName}}Gvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}")
	}
	return obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, obj.Spec.{{$link.FieldName}}Gvk.Name)
}
{{ end }}
// Link{{$link.FieldName}} links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Link{{$link.FieldName}}(ctx context.Context,
	linkToAdd *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}) (error) {
	{{ if $link.IsNamed }}
	payload := "{\"spec\": {\"{{$link.FieldNameGvk}}\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"{{$link.Kind}}\", \"group\": \"{{$link.Group}}\"}}}}"
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/{{$link.FieldNameGvk}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$link.Group}}",
		Kind:  "{{$link.Kind}}",
		Name:  linkToAdd.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ end }}
	obj.{{$node.BaseNodeName}} = result
	return nil
}

// Unlink{{$link.FieldName}} unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Unlink{{$link.FieldName}}(ctx context.Context{{if $link.IsNamed}},
	linkToRemove *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}{{end}}) (err error) {
	var patch Patch
	{{if $link.IsNamed}}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}/" + linkToRemove.DisplayName(),
	}
	{{ else }}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result
	return nil

}
{{ end }}

type {{$node.GroupResourceType}}Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *{{$node.GroupResourceType}}Chainer) Subscribe(){
    key := "{{$node.CrdName}}"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, 0, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *{{$node.GroupResourceType}}Chainer) Unsubscribe(){
	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *{{$node.GroupResourceType}}Chainer) IsSubscribed() bool {
	key := "{{$node.CrdName}}"
	 _, ok := subscriptionMap.Load(key)
	 return ok
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterEventHandler(addCB func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}), updateCB func(oldObj, newObj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}), deleteCB func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	    informer cache.SharedIndexInformer
	)
	key := "{{$node.CrdName}}"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, so creating a new one")
		informer = {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, 0, cache.Indexers{})
		go informer.Run(stopper)
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}){
			nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: c.client,
				{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
			}
			{{if .Parent.HasParent}}
			var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
			gvkExist := false
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK
				{{if .Parent.IsNamed}}
				if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; !ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				{{else}}
				if parent.Spec.{{.Parent.GoGvkFieldName}} == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				{{end}}
				gvkExist = true
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
				parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !gvkExist {
				// Check GVK
				{{if .Parent.IsNamed}}
				if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; !ok {
					return
				}
				{{else}}
				if parent.Spec.{{.Parent.GoGvkFieldName}} == nil {
					return
				}
				{{end}}
				panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
			}
			{{end}}
			addCB(nc)
		},

		UpdateFunc: func(oldObj,newObj interface{}){
			oldData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
				{{$node.BaseNodeName}}: oldObj.(*{{$node.GroupBaseImport}}),
			}
			newData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
				{{$node.BaseNodeName}}: newObj.(*{{$node.GroupBaseImport}}),
			}
			updateCB(oldData,newData)
        },

		DeleteFunc: func(obj interface{}){
			nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: c.client,
				{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
			}
			{{if .Parent.HasParent}}
			var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
			gvkExist := true
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK
				{{if .Parent.IsNamed}}
				if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				{{else}}
				if parent.Spec.{{.Parent.GoGvkFieldName}} != nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				{{end}}
				gvkExist = false
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
				parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if gvkExist {
				// Check GVK
				{{if .Parent.IsNamed}}
				if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; ok {
					return
				}
				{{else}}
				if parent.Spec.{{.Parent.GoGvkFieldName}} != nil {
					return
				}
				{{end}}
				panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
			}
			{{end}}
			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterAddCallback(cbfn func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error){
	fmt.Println("{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} -->  RegisterAddCallback!")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err error
	)
	key := "{{$node.CrdName}}"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}] ---SUBSCRIBE-INFORMER---->")
        sub := s.(subscription)
        registrationId,err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            AddFunc: func(obj interface{}){
				nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
					{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
				}

				{{if .Parent.HasParent}}
				var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{end}}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
					parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; !ok {
						return
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} == nil {
						return
					}
					{{end}}
					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}
				{{end}}

				cbfn(nc)
            },
        })
    } else {
		fmt.Println("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}] ---NEW-INFORMER---->")
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, 0, cache.Indexers{})
		registrationId,err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            AddFunc: func(obj interface{}){
				nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
				}

				{{if .Parent.HasParent}}
				var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK
					{{if .Parent.IsNamed}}
						if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
					continue
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{end}}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
					parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; !ok {
						return
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} == nil {
						return
					}
					{{end}}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}
				{{end}}

				cbfn(nc)
            },
		})
		go informer.Run(stopper)
	}
	return registrationId,err
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterUpdateCallback(cbfn func(oldObj,newObj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error){
	fmt.Println("{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} -->  RegisterUpdateCallback!")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err error
	)
	key := "{{$node.CrdName}}"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}] ---SUBSCRIBE-INFORMER---->")
        sub := s.(subscription)
        registrationId,err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            UpdateFunc: func(oldObj,newObj interface{}){
				oldData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: oldObj.(*{{$node.GroupBaseImport}}),
				}
				newData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: newObj.(*{{$node.GroupBaseImport}}),
				}
				cbfn(oldData,newData)
            },
        })
    } else {
		fmt.Println("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}] ---NEW-INFORMER---->")
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, 0, cache.Indexers{})
		registrationId,err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            UpdateFunc: func(oldObj,newObj interface{}){
				oldData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: oldObj.(*{{$node.GroupBaseImport}}),
				}
				newData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: newObj.(*{{$node.GroupBaseImport}}),
				}
				cbfn(oldData,newData)
            },
        })
		go informer.Run(stopper)
	}
	return registrationId,err
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterDeleteCallback(cbfn func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error){
	fmt.Println("{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} -->  RegisterDeleteCallback!")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err error
	)
	key := "{{$node.CrdName}}"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
        fmt.Println("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}] ---SUBSCRIBE-INFORMER---->")
        sub := s.(subscription)
        registrationId,err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            DeleteFunc: func(obj interface{}){
				nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
					{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
				}

				{{if .Parent.HasParent}}
				var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} != nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{end}}
					gvkExist = false
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
					parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; ok {
						return
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} != nil {
						return
					}
					{{end}}
					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}
				{{end}}

				cbfn(nc)
			},
        })
    } else {
		fmt.Println("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}] ---NEW-INFORMER---->")
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, 0, cache.Indexers{})
		registrationId,err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            DeleteFunc: func(obj interface{}){
				nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
				}

				{{if .Parent.HasParent}}
				var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{else}}
						if parent.Spec.{{.Parent.GoGvkFieldName}} != nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					{{end}}

					gvkExist = false

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
					parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK
					{{if .Parent.IsNamed}}
					if _, ok := parent.Spec.{{.Parent.GoGvkFieldName}}[nc.DisplayName()]; ok {
						return
					}
					{{else}}
					if parent.Spec.{{.Parent.GoGvkFieldName}} != nil {
						return
					}
					{{end}}
					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}
				{{end}}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId,err
}

{{if .HasStatus}}
// Clear{{$node.StatusName}} to clear user defined status
func (c *{{$node.GroupResourceType}}Chainer) Clear{{$node.StatusName}}(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", c.parentLabels, c.name)
	obj, err := c.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, nil)
	return err
}

// Get{{$node.StatusName}} to get user defined status
func (c *{{$node.GroupResourceType}}Chainer) Get{{$node.StatusName}}(ctx context.Context) (result *{{$node.BaseImportName}}.{{$node.StatusType}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", c.parentLabels, c.name)
	obj, err := c.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.{{$node.StatusName}}, nil
}

// Set{{$node.StatusName}} sets user defined status
func (c *{{$node.GroupResourceType}}Chainer) Set{{$node.StatusName}}(ctx context.Context, status *{{$node.BaseImportName}}.{{$node.StatusType}}) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", c.parentLabels, c.name)
	obj, err := c.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, status)
	return err
}
{{ end }}

{{ range $key, $link := .Children }}
{{ if $link.IsSingleton }}
func (c *{{$node.GroupResourceType}}Chainer) {{$link.FieldName}}() *{{$link.GroupResourceType}}Chainer {
	parentLabels := c.parentLabels
	parentLabels["{{$link.CrdName}}"] = helper.DEFAULT_KEY
	return &{{$link.GroupResourceType}}Chainer{
		client: c.client,
		name: helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// Get{{$link.FieldName}} calculates hashed name of the object based on it's parents and returns the object
func (c *{{$node.GroupResourceType}}Chainer) Get{{$link.FieldName}}(ctx context.Context) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *{{$node.GroupResourceType}}Chainer) Add{{$link.FieldName}}(ctx context.Context,
		objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *{{$node.GroupResourceType}}Chainer) Delete{{$link.FieldName}}(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, name)
	return c.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, hashedName)
}
{{ else }}
func (c *{{$node.GroupResourceType}}Chainer) {{$link.FieldName}}(name string) *{{$link.GroupResourceType}}Chainer {
	parentLabels := c.parentLabels
	parentLabels["{{$link.CrdName}}"] = name
	return &{{$link.GroupResourceType}}Chainer{
		client: c.client,
		name: name,
		parentLabels: parentLabels,
	}
}

// Get{{$link.FieldName}} calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *{{$node.GroupResourceType}}Chainer) Get{{$link.FieldName}}(ctx context.Context, displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, displayName)
	return c.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *{{$node.GroupResourceType}}Chainer) Add{{$link.FieldName}}(ctx context.Context,
	objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *{{$node.GroupResourceType}}Chainer) Delete{{$link.FieldName}}(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, name)
	return c.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

{{ end }}
{{ end }}
{{ end }}